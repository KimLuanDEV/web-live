<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Viewer</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>üëÄ Viewer (Ng∆∞·ªùi xem)</h1>
      <small>M·ªü link n√†y ƒë·ªÉ xem live.</small>
      <hr />

      <div class="row">
        <div class="card">
          <div class="kv">
            <div class="badge">Ph√≤ng</div>
            <code id="roomCode">-</code>

            <div class="badge" id="statusBadge">‚è≥ ƒêang ch·ªù broadcaster...</div>

            <button id="btnJoin">Join / Start Watching</button>
          </div>

          <hr />
          <div class="log" id="log"></div>
        </div>

        <div class="card">
         <div class="video-card" style="margin-top:10px">
  <div class="live-overlay">
    <span class="dot"></span>
    <b>LIVE</b>
    <span id="liveStatusText" style="opacity:.85"></span>
  </div>

  <div class="video-card__inner">
    <video id="player" autoplay playsinline controls></video>
  </div>

<hr />
<div class="badge">üë§ Guest</div>
<div class="video-wrap" style="margin-top:10px">
  <video id="guestPlayer" autoplay playsinline controls></video>
</div>


</div>

         
        </div>
      </div>
    </div>
  </div>

<hr />
<div class="card chat">
  <div class="badge badge--info">üí¨ Chat</div>

  <div class="chatform">
    <input id="chatName" placeholder="T√™n c·ªßa b·∫°n" />
    <input id="chatText" placeholder="Nh·∫≠p tin nh·∫Øn..." />
    <button id="chatSend" class="full">G·ª≠i</button>
  </div>

  <div id="chatBox" class="chatbox"></div>
</div>



  <script src="/socket.io/socket.io.js"></script>
  <script>
    const logEl = document.getElementById("log");
    const badge = document.getElementById("statusBadge");
    const player = document.getElementById("player");
    const btnJoin = document.getElementById("btnJoin");

    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || "abc123";
    document.getElementById("roomCode").textContent = roomId;

    const socket = io();

    const pcs = new Map(); // fromId -> RTCPeerConnection
let guestId = null;
let hostId = null;
const guestPlayer = document.getElementById("guestPlayer");


    let joined = false;

  async function getRtcConfig() {
  const fallback = {
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  };

  try {
    const r = await fetch("/ice", { cache: "no-store" });
    if (!r.ok) return fallback;

    const data = await r.json();
    if (!data.iceServers || !Array.isArray(data.iceServers)) return fallback;

    // üî• FIX CH√çNH ·ªû ƒê√ÇY
    const cleanedIceServers = data.iceServers
      .map(server => {
        let urls = server.urls;
        if (!urls) return null;

        if (!Array.isArray(urls)) urls = [urls];

        // ‚ùå LO·∫†I B·ªé STUN TWILIO C√ì ?transport=
        const safeUrls = urls.filter(u =>
          typeof u === "string" &&
          !(u.startsWith("stun:") && u.includes("?transport="))
        );

        if (safeUrls.length === 0) return null;

        return {
          ...server,
          urls: safeUrls
        };
      })
      .filter(Boolean);

    if (cleanedIceServers.length === 0) return fallback;

    return { iceServers: cleanedIceServers };

  } catch (e) {
    console.error("ICE fetch error:", e);
    return fallback;
  }
}


    function log(msg) {
      logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

   const liveStatusText = document.getElementById("liveStatusText");
function setStatus(text) {
  badge.textContent = text;
  if (liveStatusText) liveStatusText.textContent = text.replace(/^[^ ]+\s*/, "");
}





    socket.on("broadcaster-online", () => setStatus("‚úÖ Broadcaster online"));
    socket.on("broadcaster-offline", () => setStatus("‚õî Broadcaster offline"));
    socket.on("broadcaster-changed", () => {
      setStatus("üîÑ Broadcaster changed ‚Äì refresh if needed");
      // reset connection
      cleanup();
    });

    async function join() {
      if (joined) return;
  joined = true;

  socket.emit("join-room", { roomId, role: "viewer" });
  setStatus("‚è≥ ƒêang ch·ªù broadcaster g·ª≠i LIVE...");
  log("ƒê√£ join room, ƒë·ª£i offer t·ª´ broadcaster...");

  /*
    const rtcConfig = await getRtcConfig();
pc = new RTCPeerConnection(rtcConfig);
*/

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          // send to broadcaster (server will route by socket id in offer/answer messages)
          // but we don't know broadcaster id; so we send "to" later after offer arrives.
          // We'll store candidates until we know "offer.from"
        }
      };

      // Receive stream
      pc.ontrack = (event) => {
        player.srcObject = event.streams[0];
        setStatus("üü¢ ƒêang xem LIVE");
        log("ƒê√£ nh·∫≠n stream.");

        // autoplay can be blocked; try play, otherwise user clicks play
        player.play().catch(() => log("Autoplay b·ªã ch·∫∑n, h√£y b·∫•m Play tr√™n video."));
      };

      pc.oniceconnectionstatechange = () => {
        log("ICE state: " + pc.iceConnectionState);
      };
    }

socket.on("guest-online", ({ guestId: gid }) => {
  guestId = gid;
  socket.emit("watch-guest", { roomId });
});

socket.on("guest-offline", () => {
  guestId = null;
  guestPlayer.srcObject = null;
});


    // Because we need to send ICE candidates to the broadcaster that sent the offer,
    // we keep offerFrom
    let offerFrom = null;

  socket.on("offer", async ({ from, description }) => {
  // n·∫øu ch∆∞a bi·∫øt hostId, l·∫•y offer ƒë·∫ßu ti√™n kh√¥ng ph·∫£i guest l√†m host
  if (!hostId && from !== guestId) hostId = from;

  // close pc c≈© c·ªßa peer n√†y n·∫øu c√≥
  const old = pcs.get(from);
  if (old) { try{ old.close(); }catch{} pcs.delete(from); }

  const rtcConfig = await getRtcConfig();
  const pc = new RTCPeerConnection(rtcConfig);
  pcs.set(from, pc);

  pc.ontrack = (event) => {
    const stream = event.streams[0];
    if (from === guestId) {
      guestPlayer.srcObject = stream;
      log("ƒê√£ nh·∫≠n stream GUEST.");
    } else {
      player.srcObject = stream;
      log("ƒê√£ nh·∫≠n stream HOST.");
    }
    setStatus("üü¢ ƒêang xem LIVE");
    (from === guestId ? guestPlayer : player).play().catch(() => {});
  };

  pc.onicecandidate = (e) => {
    if (e.candidate) socket.emit("candidate", { to: from, candidate: e.candidate });
  };

  try {
    await pc.setRemoteDescription(description);
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    socket.emit("answer", { to: from, description: pc.localDescription });
    setStatus("üü° ƒêang b·∫Øt tay k·∫øt n·ªëi...");
    log("ƒê√£ g·ª≠i answer cho: " + from);
  } catch (err) {
    log("L·ªói x·ª≠ l√Ω offer: " + err.message);
  }
});



    socket.on("candidate", async ({ from, candidate }) => {
  const pc = pcs.get(from);
  if (!pc) return;
  try { await pc.addIceCandidate(candidate); }
  catch (err) { log("L·ªói addIceCandidate: " + err.message); }
});


    function cleanup() {
      if (pc) {
        pc.close();
        pc = null;
      }
      offerFrom = null;
      player.srcObject = null;
      joined = false;
      log("Reset viewer connection.");
    }

    btnJoin.onclick = () => {
      join().catch(err => {
        log("Join l·ªói: " + err.message);
      });
    };


    // ===== CHAT (VIEWER) =====
const chatBox = document.getElementById("chatBox");
const chatName = document.getElementById("chatName");
const chatText = document.getElementById("chatText");
const chatSend = document.getElementById("chatSend");

function addChat(msg) {
  const time = new Date(msg.ts).toLocaleTimeString();
  chatBox.textContent += `[${time}] ${msg.name}: ${msg.text}\n`;
  chatBox.scrollTop = chatBox.scrollHeight;
}

socket.on("chat", addChat);

chatSend.onclick = () => {
  const name = (chatName.value || "Viewer").trim();
  const text = chatText.value.trim();
  if (!text) return;

  socket.emit("chat", { roomId, name, text });
  chatText.value = "";
};


function addChat(msg) {
  const time = new Date(msg.ts).toLocaleTimeString();
  const line = document.createElement("div");
  line.textContent = `[${time}] ${msg.name}: ${msg.text}`;
  chatBox.appendChild(line);
  chatBox.scrollTop = chatBox.scrollHeight;
}

  </script>
</body>
</html>
