<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Viewer</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>üëÄ Viewer (Ng∆∞·ªùi xem)</h1>
      <small>M·ªü link n√†y ƒë·ªÉ xem live.</small>
      <hr />

      <div class="row">
        <div class="card">
          <div class="kv">
            <div class="badge">Ph√≤ng</div>
            <code id="roomCode">-</code>

            <div class="badge" id="statusBadge">‚è≥ ƒêang ch·ªù broadcaster...</div>

            <button id="btnJoin">Join / Start Watching</button>
          </div>

          <hr />
          <div class="log" id="log"></div>
        </div>

        <div class="card">
          <div class="badge">Live</div>
          <div class="video-wrap" style="margin-top:10px">
            <!-- controls ƒë·ªÉ ng∆∞·ªùi xem d·ªÖ b·∫≠t ti·∫øng -->
            <video id="player" autoplay playsinline controls></video>
          </div>
          <small>N·∫øu b·ªã im ti·∫øng: b·∫•m Play/Unmute tr√™n video.</small>
        </div>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const logEl = document.getElementById("log");
    const badge = document.getElementById("statusBadge");
    const player = document.getElementById("player");
    const btnJoin = document.getElementById("btnJoin");

    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || "abc123";
    document.getElementById("roomCode").textContent = roomId;

    const socket = io();
    let pc = null;
    let joined = false;

    const RTC_CONFIG = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:global.stun.twilio.com:3478?transport=udp" }
      ]
    };

    function log(msg) {
      logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

    function setStatus(text) {
      badge.textContent = text;
    }

    socket.on("broadcaster-online", () => setStatus("‚úÖ Broadcaster online"));
    socket.on("broadcaster-offline", () => setStatus("‚õî Broadcaster offline"));
    socket.on("broadcaster-changed", () => {
      setStatus("üîÑ Broadcaster changed ‚Äì refresh if needed");
      // reset connection
      cleanup();
    });

    async function join() {
      if (joined) return;
      joined = true;

      socket.emit("join-room", { roomId, role: "viewer" });
      setStatus("‚è≥ ƒêang k·∫øt n·ªëi...");

      pc = new RTCPeerConnection(RTC_CONFIG);

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          // send to broadcaster (server will route by socket id in offer/answer messages)
          // but we don't know broadcaster id; so we send "to" later after offer arrives.
          // We'll store candidates until we know "offer.from"
        }
      };

      // Receive stream
      pc.ontrack = (event) => {
        player.srcObject = event.streams[0];
        setStatus("üü¢ ƒêang xem LIVE");
        log("ƒê√£ nh·∫≠n stream.");

        // autoplay can be blocked; try play, otherwise user clicks play
        player.play().catch(() => log("Autoplay b·ªã ch·∫∑n, h√£y b·∫•m Play tr√™n video."));
      };

      pc.oniceconnectionstatechange = () => {
        log("ICE state: " + pc.iceConnectionState);
      };
    }

    // Because we need to send ICE candidates to the broadcaster that sent the offer,
    // we keep offerFrom
    let offerFrom = null;

    socket.on("offer", async ({ from, description }) => {
      offerFrom = from;

      if (!pc) {
        pc = new RTCPeerConnection(RTC_CONFIG);
        pc.ontrack = (event) => {
          player.srcObject = event.streams[0];
          setStatus("üü¢ ƒêang xem LIVE");
          log("ƒê√£ nh·∫≠n stream.");
          player.play().catch(() => log("Autoplay b·ªã ch·∫∑n, h√£y b·∫•m Play."));
        };
        pc.onicecandidate = (e) => {
          if (e.candidate && offerFrom) {
            socket.emit("candidate", { to: offerFrom, candidate: e.candidate });
          }
        };
      }

      try {
        await pc.setRemoteDescription(description);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("answer", { to: from, description: pc.localDescription });
        setStatus("üü° ƒêang b·∫Øt tay k·∫øt n·ªëi...");
        log("ƒê√£ g·ª≠i answer.");
      } catch (err) {
        log("L·ªói x·ª≠ l√Ω offer: " + err.message);
      }
    });

    socket.on("candidate", async ({ from, candidate }) => {
      if (!pc) return;
      try {
        await pc.addIceCandidate(candidate);
      } catch (err) {
        log("L·ªói addIceCandidate: " + err.message);
      }
    });

    function cleanup() {
      if (pc) {
        pc.close();
        pc = null;
      }
      offerFrom = null;
      player.srcObject = null;
      joined = false;
      log("Reset viewer connection.");
    }

    btnJoin.onclick = () => {
      join().catch(err => {
        log("Join l·ªói: " + err.message);
      });
    };
  </script>
</body>
</html>
