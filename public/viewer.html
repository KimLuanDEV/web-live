<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Viewer</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1> ğŸ‘ Viewer</h1>
      
      <hr />

      <div class="row">
        <div class="card">
          <div class="kv">
            <div class="badge">PhÃ²ng Livestream</div>
            <code id="roomCode">-</code>

            <div class="badge" id="statusBadge">â³ Äang chá»...</div>

            <button id="btnJoin">Tham gia xem Livestream</button>
          </div>

<button id="btnRequestLive" style="margin-top:10px">ğŸ¤ Xin lÃªn live</button>
<small id="reqTip" style="display:block;opacity:.8;margin-top:6px">
  Báº¥m Ä‘á»ƒ má»Ÿ trang KhÃ¡ch vÃ  gá»­i yÃªu cáº§u lÃªn Host.
</small>

          <hr />
          <div class="log" id="log" style="display: none;"></div>
        </div>

        <div class="card">

        <div class="live-stage" id="liveStage" style="margin-top:10px">
  <!-- HOST -->
  <div class="video-card live-main" id="hostCard">
    <div class="live-overlay">
      <span class="dot"></span>
      <b>LIVE</b>
      <span class="live-meta">
        <span class="meta-item" id="viewerCountViewer">ğŸ‘ 0</span>
        <span class="meta-sep">â€¢</span>
        <span class="meta-item" id="liveTimerViewer">â± 00:00:00</span>
      </span>
    </div>
<div class="chat-overlay" id="chatOverlay"></div>
<div class="join-overlay" id="joinOverlayViewer" aria-live="polite"></div>
<div class="pin-overlay" id="pinOverlay"></div>

        <div class="reactions-layer" id="reactionsLayerViewer"></div>
<div class="video-card__inner">
      <video id="player" autoplay playsinline></video>
    </div>
  </div>

  <!-- GUEST (PIP) -->
  <div class="pip-wrap" id="guestPipWrap" aria-hidden="true">
    <div class="pip-badge">ğŸ‘¤ GUEST</div>
    <video id="guestPlayer" autoplay playsinline></video>
  </div>
</div>


        </div>
      </div>
    </div>
  </div>

<hr />
<div class="card chat">
  <div class="badge badge--info">ğŸ’¬ Chat (Live)</div>

  <div class="chatform">
    <input id="chatName" placeholder="TÃªn cá»§a báº¡n" />
    <input id="chatText" placeholder="Nháº­p tin nháº¯n..." />
    <button id="chatSend" class="full">Gá»­i</button>
  </div>

  <div class="emoji-bar" id="emojiBar">
    <button type="button" class="emoji-btn" data-emoji="â¤ï¸">â¤ï¸</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ”¥">ğŸ”¥</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ˜‚">ğŸ˜‚</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ˜®">ğŸ˜®</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ˜¢">ğŸ˜¢</button>
  </div>


  <div id="chatBox" class="chatbox"></div>
</div>



  <!-- ===== Inline Guest Panel (viewer xin lÃªn live ngay táº¡i Ä‘Ã¢y) ===== -->
<div id="inlineGuestPanel" class="inline-guest" style="display:none">
  <div class="inline-guest__head">
    <div id="inlineGuestStatus" class="inline-guest__status">â³ Chá» host duyá»‡t...</div>
    <button id="inlineGuestClose" class="inline-guest__close" type="button" aria-label="ÄÃ³ng">âœ•</button>
  </div>

  <div class="inline-guest__videoWrap">
    <video id="inlineGuestMe" autoplay playsinline muted></video>
  </div>

  <div class="inline-guest__controls">
    <button id="inlineGuestMicBtn" type="button" title="Báº­t / Táº¯t mic">ğŸ™ï¸</button>
    <button id="inlineGuestCamBtn" type="button" title="Báº­t / Táº¯t camera">ğŸ“·</button>
    <button id="inlineGuestFlipBtn" type="button" title="Äáº£o camera" disabled>ğŸ”„</button>
    <button id="inlineGuestLeaveBtn" type="button" title="Rá»i live" disabled>ğŸšª</button>
  </div>
</div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const logEl = document.getElementById("log");
    const badge = document.getElementById("statusBadge");
    const player = document.getElementById("player");
    const guestPlayer = document.getElementById("guestPlayer");
    const btnJoin = document.getElementById("btnJoin");

    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || "abc123";
    document.getElementById("roomCode").textContent = roomId;

const liveStage = document.getElementById("liveStage");
const guestPipWrap = document.getElementById("guestPipWrap");

let swapped = false; // false: host main, true: guest main


    const socket = io();
// ===== PIN NOTE (display only) =====
const pinOverlay = document.getElementById("pinOverlay");
function __clamp01(n){ n = Number(n); if (!isFinite(n)) return 0.5; return Math.max(0, Math.min(1, n)); }
function renderPin(note){
  if (!pinOverlay) return;
  pinOverlay.innerHTML = "";
  if (!note) return;
  const wrap = document.createElement("div");
  wrap.className = "pin-note";
  wrap.style.left = (__clamp01(note.x) * 100).toFixed(3) + "%";
  wrap.style.top  = (__clamp01(note.y) * 100).toFixed(3) + "%";

  const head = document.createElement("div");
  head.className = "pin-head";
  const title = document.createElement("div");
  title.className = "pin-title";
  title.innerHTML = ``;
  head.appendChild(title);

  const body = document.createElement("div");
  body.className = "pin-body";
  body.textContent = String(note.text || "");

  wrap.appendChild(head);
  wrap.appendChild(body);
  pinOverlay.appendChild(wrap);
}
socket.on("pin-note-update", (note)=> renderPin(note));
// ===== /PIN NOTE =====

// ===== LIVE TIMER (HH:MM:SS) =====
let __liveStartTs = null;
let __liveTick = null;

function __pad2(n){ n = Math.floor(Math.max(0, n)); return String(n).padStart(2,"0"); }
function __fmtHMS(ms){
  const s = Math.floor(ms/1000);
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  const ss = s%60;
  return `${__pad2(hh)}:${__pad2(mm)}:${__pad2(ss)}`;
}
function __setTimerText(el, ms){
  if (!el) return;
  el.textContent = `â± ${__fmtHMS(ms)}`;
}
function __startTimer(el, startTs){
  __liveStartTs = startTs;
  if (__liveTick) clearInterval(__liveTick);
  __setTimerText(el, Date.now() - __liveStartTs);
  __liveTick = setInterval(()=>__setTimerText(el, Date.now() - __liveStartTs), 250);
}
function __stopTimer(el){
  __liveStartTs = null;
  if (__liveTick) clearInterval(__liveTick);
  __liveTick = null;
  if (el) el.textContent = "â± 00:00:00";
}

const liveTimerViewer = document.getElementById("liveTimerViewer");
socket.on("live-start", ({ startTs }) => {
  if (typeof startTs === "number") __startTimer(liveTimerViewer, startTs);
});
socket.on("live-stop", () => {
  __stopTimer(liveTimerViewer);
});


// ===== REACTIONS (tap/click to heart) =====
function clamp01(n){ return Math.max(0, Math.min(1, n)); }
function now(){ return Date.now(); }

function attachTapToHeart(tapEl, layerEl, getRoomIdFn) {
  if (!tapEl || !layerEl) return;
  let last = 0;
  const MIN_MS = 180; // anti-spam client side

  const handler = (ev) => {
    // prevent video click from toggling play/pause
    try { if (ev && ev.cancelable) ev.preventDefault(); } catch {}
    try { ev.stopPropagation(); } catch {}
    // ignore clicks on controls/buttons/inputs
    const t = ev.target;
    if (t && (t.closest("button") || t.closest("input") || t.closest("textarea"))) return;

    const ts = now();
    if (ts - last < MIN_MS) return;
    last = ts;

    const rect = tapEl.getBoundingClientRect();
    const cx = ("clientX" in ev) ? ev.clientX : (ev.touches && ev.touches[0] ? ev.touches[0].clientX : rect.left + rect.width/2);
    const cy = ("clientY" in ev) ? ev.clientY : (ev.touches && ev.touches[0] ? ev.touches[0].clientY : rect.top + rect.height/2);
    const x = clamp01((cx - rect.left) / rect.width);
    const y = clamp01((cy - rect.top) / rect.height);

    const msg = { roomId: getRoomIdFn(), emoji: "â¤ï¸", x, y };
    // show immediately on self
    spawnReaction(layerEl, msg.emoji, msg.x, msg.y, true);
    socket.emit("reaction", msg);
  };

  tapEl.addEventListener("pointerdown", handler, { passive: false });
  // also fallback for old browsers
  tapEl.addEventListener("click", handler);
}

function spawnReaction(layerEl, emoji, x, y, local=false) {
  if (!layerEl) return;
  const el = document.createElement("div");
  el.className = "reaction-float";
  el.textContent = emoji || "â¤ï¸";
  // random motion
  const dx = (Math.random() * 120 - 60).toFixed(1); // px
  const rot = (Math.random() * 30 - 15).toFixed(1); // deg
  const sc = (0.85 + Math.random() * 0.8).toFixed(2);
  el.style.setProperty("--x", String(x));
  el.style.setProperty("--y", String(y));
  el.style.setProperty("--dx", dx + "px");
  el.style.setProperty("--rot", rot + "deg");
  el.style.setProperty("--sc", sc);
  if (local) el.classList.add("is-local");
  layerEl.appendChild(el);
  setTimeout(()=>{ try{ el.remove(); }catch{} }, 1800);
}

socket.on("reaction", (msg)=>{
  try {
    if (!msg) return;
    const emoji = msg.emoji || "â¤ï¸";
    const x = clamp01(Number(msg.x ?? 0.5));
    const y = clamp01(Number(msg.y ?? 0.7));
    // choose layer based on whether it's guest/host layer (we only have one layer per page for now)
    const layer = document.getElementById("reactionsLayerViewer");
    spawnReaction(layer, emoji, x, y, false);
  } catch (e) {
    console.warn("reaction render error", e);
  }
});

// ===== INIT TAP-TO-HEART on main live card =====
(function initTapHearts(){
  const __tapEl = document.getElementById("hostCard");
  const __layerEl = document.getElementById("reactionsLayerViewer");
  if (!__tapEl || !__layerEl) return;
  attachTapToHeart(__tapEl, __layerEl, ()=>roomId);
})();


    let joined = false;

    // multiple peer connections: broadcaster + guest
    const pcs = new Map(); // peerId -> RTCPeerConnection
    let guestId = null;

    async function getRtcConfig() {
      const fallback = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

      try {
        const r = await fetch("/ice", { cache: "no-store" });
        if (!r.ok) return fallback;

        const data = await r.json();
        if (!data.iceServers || !Array.isArray(data.iceServers)) return fallback;

        // Remove invalid STUN urls that contain ?transport=
        const cleanedIceServers = data.iceServers
          .map(server => {
            let urls = server.urls;
            if (!urls) return null;
            if (!Array.isArray(urls)) urls = [urls];

            const safeUrls = urls.filter(u =>
              typeof u === "string" &&
              !(u.startsWith("stun:") && u.includes("?transport="))
            );
            if (safeUrls.length === 0) return null;
            return { ...server, urls: safeUrls };
          })
          .filter(Boolean);

        if (cleanedIceServers.length === 0) return fallback;
        return { iceServers: cleanedIceServers };
      } catch (e) {
        console.error("ICE fetch error:", e);
        return fallback;
      }
    }

    function log(msg) {
      logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

    const liveStatusText = document.getElementById("liveStatusText");
    function setStatus(text) {
      badge.textContent = text;
      if (liveStatusText) liveStatusText.textContent = text.replace(/^[^ ]+\s*/, "");
    }

    socket.on("broadcaster-online", () => setStatus("âœ… Host online"));
    socket.on("broadcaster-offline", () => setStatus("â›” Host offline"));
    socket.on("broadcaster-changed", () => {
      setStatus("ğŸ”„ Host changed â€“ hÃ£y báº¥m Join láº¡i");
      cleanupAll();
    });

    // guest events
    socket.on("guest-online", ({ guestId: gid }) => {

      document.body.classList.add("has-guest");
if (guestPipWrap) guestPipWrap.setAttribute("aria-hidden", "false");

      guestId = gid;
      log("Guest online: " + gid);
      setStatus("ğŸŸ¢ CÃ³ Guest cÃ¹ng live");
      // request guest to stream to this viewer
      socket.emit("watch-guest", { roomId });
    });

    socket.on("guest-offline", () => {

      document.body.classList.remove("has-guest");
document.body.classList.remove("swap-live");
swapped = false;
if (guestPipWrap) guestPipWrap.setAttribute("aria-hidden", "true");

      log("Guest offline");
      guestId = null;
      guestPlayer.srcObject = null;
      // close guest pc if exists
      cleanupPeer("guest");
    });



    async function join() {
      if (joined) return;
      joined = true;
      
      try{ btnJoin.style.display = "none"; }catch{}
socket.emit("join-room", { roomId, role: "viewer" });
      setStatus("â³ Äang chá» Host gá»­i LIVE...");
      log("ÄÃ£ join room, Ä‘á»£i offer tá»« host/guest...");
    }

    function cleanupPeer(peerKey) {
      // peerKey can be actual peerId or "guest"
      if (peerKey === "guest") {
        // find by guestId if present
        if (guestId && pcs.has(guestId)) {
          try { pcs.get(guestId).close(); } catch {}
          pcs.delete(guestId);
        }
        return;
      }
      const pc = pcs.get(peerKey);
      if (pc) {
        try { pc.close(); } catch {}
        pcs.delete(peerKey);
      }
    }

    function cleanupAll() {
      for (const pc of pcs.values()) {
        try { pc.close(); } catch {}
      }
      pcs.clear();
      player.srcObject = null;
      guestPlayer.srcObject = null;
      joined = false;
    }

    // Receive offer from broadcaster OR guest
    socket.on("offer", async ({ from, description }) => {
      // reset pc for this peer only
      cleanupPeer(from);

      const rtcConfig = await getRtcConfig();
      const pc = new RTCPeerConnection(rtcConfig);
      pcs.set(from, pc);

      pc.ontrack = (event) => {
        const stream = event.streams[0];

        if (guestId && from === guestId) {
          guestPlayer.srcObject = stream;
          log("ÄÃ£ nháº­n stream GUEST.");
          guestPlayer.play().catch(() => log("Autoplay bá»‹ cháº·n, báº¥m Play á»Ÿ video Guest."));
        } else {
          player.srcObject = stream;
          log("ÄÃ£ nháº­n stream HOST.");
          player.play().catch(() => log("Autoplay bá»‹ cháº·n, báº¥m Play á»Ÿ video Host."));
        }

        setStatus("ğŸŸ¢ Äang xem LIVE");
      };

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          socket.emit("candidate", { to: from, candidate: e.candidate });
        }
      };

      pc.oniceconnectionstatechange = () => {
        log(`ICE(${from}): ${pc.iceConnectionState}`);
      };

      try {
        await pc.setRemoteDescription(description);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("answer", { to: from, description: pc.localDescription });
        setStatus("ğŸŸ¢ Äang xem live trá»±c tiáº¿p.");
        log("ÄÃ£ gá»­i answer cho: " + from);
      } catch (err) {
        log("Lá»—i xá»­ lÃ½ offer: " + err.message);
      }
    });

    socket.on("candidate", async ({ from, candidate }) => {
  // If we're in inline-guest mode, candidates for offerer PCs come here
  if (typeof guestOfferPCs !== "undefined" && guestOfferPCs && guestOfferPCs.has(from)) {
    const pcG = guestOfferPCs.get(from);
    try { await pcG.addIceCandidate(candidate); }
    catch (err) { log("Inline-Guest: lá»—i addIceCandidate: " + (err?.message || err)); }
    return;
  }

  const pc = pcs.get(from);
  if (!pc) return;
  try {
    await pc.addIceCandidate(candidate);
  } catch (err) {
    log("Lá»—i addIceCandidate: " + err.message);
  }
});

    btnJoin.onclick = () => {
      join().catch(err => log("Join lá»—i: " + err.message));
    };

    // âœ… Auto-join on load (viewer sáº½ tá»± tham gia xem, khÃ´ng cáº§n báº¥m nÃºt)
    (function autoJoinViewer(){
      try {
        btnJoin.disabled = true;
        btnJoin.textContent = "â³ Äang tham gia...";
        // delay nháº¹ Ä‘á»ƒ Ä‘áº£m báº£o socket vÃ  UI Ä‘Ã£ sáºµn sÃ ng
        setTimeout(() => {
          join().catch(err => {
            // náº¿u lá»—i, má»Ÿ láº¡i nÃºt cho user báº¥m thá»­
            btnJoin.disabled = false;
            btnJoin.textContent = "Tham gia xem Livestream";
            log("Auto-join lá»—i: " + (err?.message || err));
          });
        }, 120);
      } catch {}
    })();


// ===== REQUEST TO GO LIVE (VIEWER -> INLINE GUEST) =====
const btnRequestLive = document.getElementById("btnRequestLive");

// Inline guest UI
const inlineGuestPanel   = document.getElementById("inlineGuestPanel");
const inlineGuestStatus  = document.getElementById("inlineGuestStatus");
const inlineGuestClose   = document.getElementById("inlineGuestClose");
const inlineGuestMe      = document.getElementById("inlineGuestMe");
const inlineGuestMicBtn  = document.getElementById("inlineGuestMicBtn");
const inlineGuestCamBtn  = document.getElementById("inlineGuestCamBtn");
const inlineGuestFlipBtn = document.getElementById("inlineGuestFlipBtn");
const inlineGuestLeaveBtn= document.getElementById("inlineGuestLeaveBtn");

function setInlineGuestStatus(t){
  if (inlineGuestStatus) inlineGuestStatus.textContent = t;
}

// default disable until host online
btnRequestLive.disabled = true;

// offerer PCs for when THIS viewer becomes guest
const guestOfferPCs = new Map(); // peerId -> RTCPeerConnection
let inlineLocalStream = null;
let inlineFacing = "user";
let inlineGuestMode = false;
let inlineMicOn = true;
let inlineCamOn = true;

function cleanupInlineGuestPeers(){
  for (const pc of guestOfferPCs.values()) { try { pc.close(); } catch {} }
  guestOfferPCs.clear();
}
function stopInlineLocal(){
  if (inlineLocalStream) {
    try { inlineLocalStream.getTracks().forEach(t => t.stop()); } catch {}
  }
  inlineLocalStream = null;
  try { if (inlineGuestMe) inlineGuestMe.srcObject = null; } catch {}
}

async function startInlineGuest(){
  if (inlineGuestMode) return;
  inlineGuestMode = true;

  try{
    if (inlineGuestPanel) inlineGuestPanel.style.display = "block";
    setInlineGuestStatus("â³ Äang xin quyá»n camera/mic...");

    inlineLocalStream = await navigator.mediaDevices.getUserMedia({
      video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { ideal: inlineFacing } },
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
    });

    if (inlineGuestMe) inlineGuestMe.srcObject = inlineLocalStream;

    inlineGuestFlipBtn.disabled = false;
    inlineGuestLeaveBtn.disabled = false;

    // chuyá»ƒn role sang guest (khÃ´ng má»Ÿ tab má»›i)
    socket.emit("switch-to-guest", { roomId });

    setInlineGuestStatus("â³ ÄÃ£ báº­t cam/mic. Äang chá» host duyá»‡t...");
  } catch (e){
    inlineGuestMode = false;
    if (inlineGuestPanel) inlineGuestPanel.style.display = "none";
    alert("KhÃ´ng má»Ÿ Ä‘Æ°á»£c camera/mic: " + (e?.message || e));
  }
}

function leaveInlineGuest(){
  cleanupInlineGuestPeers();
  stopInlineLocal();

  inlineGuestMode = false;
  if (inlineGuestPanel) inlineGuestPanel.style.display = "none";

  // quay láº¡i role viewer
  socket.emit("switch-to-viewer", { roomId });
}

// click xin lÃªn live
btnRequestLive.onclick = () => startInlineGuest();

// close / leave
if (inlineGuestClose) inlineGuestClose.onclick = () => leaveInlineGuest();
if (inlineGuestLeaveBtn) inlineGuestLeaveBtn.onclick = () => leaveInlineGuest();

// mic/cam toggle (local)
if (inlineGuestMicBtn) inlineGuestMicBtn.onclick = () => {
  if (!inlineLocalStream) return;
  const at = inlineLocalStream.getAudioTracks()[0];
  if (!at) return;

  inlineMicOn = !inlineMicOn;
  at.enabled = inlineMicOn;

  inlineGuestMicBtn.classList.toggle("off", !inlineMicOn);
  inlineGuestMicBtn.textContent = inlineMicOn ? "ğŸ™ï¸" : "ğŸ”‡";
};

if (inlineGuestCamBtn) inlineGuestCamBtn.onclick = () => {
  if (!inlineLocalStream) return;
  const vt = inlineLocalStream.getVideoTracks()[0];
  if (!vt) return;

  inlineCamOn = !inlineCamOn;
  vt.enabled = inlineCamOn;

  inlineGuestCamBtn.classList.toggle("off", !inlineCamOn);
  inlineGuestCamBtn.textContent = inlineCamOn ? "ğŸ“·" : "ğŸš«";
};

// flip camera (replaceTrack)
if (inlineGuestFlipBtn) inlineGuestFlipBtn.onclick = async () => {
  if (!inlineLocalStream) return;
  inlineFacing = (inlineFacing === "user") ? "environment" : "user";

  try{
    const newStream = await navigator.mediaDevices.getUserMedia({
      video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { ideal: inlineFacing } },
      audio: false
    });
    const newVideoTrack = newStream.getVideoTracks()[0];
    if (!newVideoTrack) throw new Error("KhÃ´ng láº¥y Ä‘Æ°á»£c camera má»›i");

    const oldVideoTrack = inlineLocalStream.getVideoTracks()[0];
    if (oldVideoTrack) {
      inlineLocalStream.removeTrack(oldVideoTrack);
      oldVideoTrack.stop();
    }
    inlineLocalStream.addTrack(newVideoTrack);

    if (inlineGuestMe) inlineGuestMe.srcObject = inlineLocalStream;

    // replace for all offerer PCs
    for (const pc of guestOfferPCs.values()){
      const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
      if (sender) await sender.replaceTrack(newVideoTrack);
    }
  } catch (e){
    alert("KhÃ´ng Ä‘áº£o Ä‘Æ°á»£c camera: " + (e?.message || e));
  }
};

// tráº¡ng thÃ¡i duyá»‡t guest
socket.on("guest-pending", () => setInlineGuestStatus("â³ Äang chá» host duyá»‡t..."));
socket.on("guest-rejected", () => setInlineGuestStatus("â›” Host tá»« chá»‘i."));
socket.on("guest-approved", () => setInlineGuestStatus("âœ… ÄÆ°á»£c duyá»‡t! Báº¡n Ä‘ang lÃªn live."));
socket.on("guest-kicked", () => {
  alert("Báº¡n Ä‘Ã£ bá»‹ Host kÃ­ch khá»i live.");
  leaveInlineGuest();
});

// chá»‰ cho xin lÃªn live khi host online
socket.on("broadcaster-online", () => { btnRequestLive.disabled = false; });
socket.on("broadcaster-offline", () => { btnRequestLive.disabled = true; });

// Khi ai Ä‘Ã³ muá»‘n xem guest => server yÃªu cáº§u guest táº¡o offer cho viewer Ä‘Ã³
socket.on("guest-watcher", async ({ viewerId }) => {
  if (!inlineLocalStream) return;
  if (!viewerId) return;
  if (guestOfferPCs.has(viewerId)) return;

  try{
    log("Inline-Guest: táº¡o káº¿t ná»‘i tá»›i viewer " + viewerId);

    const rtcConfig = await getRtcConfig();
    const pc = new RTCPeerConnection(rtcConfig);
    guestOfferPCs.set(viewerId, pc);

    inlineLocalStream.getTracks().forEach(t => pc.addTrack(t, inlineLocalStream));

    pc.onicecandidate = (e) => {
      if (e.candidate) socket.emit("candidate", { to: viewerId, candidate: e.candidate });
    };

    // Host sáº½ addTrack khi answer => náº¿u muá»‘n nghe host thÃ¬ cÃ³ thá»ƒ map stream vÃ o player
    pc.ontrack = (e) => {
      // optional: dÃ¹ng Ä‘á»ƒ nghe host audio khi Ä‘ang lÃªn live
      // player.srcObject = e.streams[0];
    };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.emit("offer", { to: viewerId, description: pc.localDescription });
  } catch (err){
    log("Inline-Guest: lá»—i táº¡o offer: " + (err?.message || err));
  }
});

// inline guest receives answers (because it's offerer)
socket.on("answer", async ({ from, description }) => {
  const pc = guestOfferPCs.get(from);
  if (!pc) return;
  try { await pc.setRemoteDescription(description); }
  catch (err){ log("Inline-Guest: lá»—i setRemoteDescription(answer): " + (err?.message || err)); }
});
// ===== /REQUEST TO GO LIVE =====




    // ===== CHAT (VIEWER) =====
    const chatBox = document.getElementById("chatBox");
    const chatName = document.getElementById("chatName");
    const chatText = document.getElementById("chatText");
    const chatSend = document.getElementById("chatSend");

    function addChat(msg) {
      const time = new Date(msg.ts).toLocaleTimeString();
      const role = String(msg.role || "viewer");
      const tag = role === "host" ? "[HOST]" : role === "guest" ? "[GUEST]" : "";
      const line = document.createElement("div");
      line.className = "chat-line chat-" + role;
      line.textContent = `[${time}] ${tag ? tag + " " : ""}${msg.name}: ${msg.text}`;
      chatBox.appendChild(line);
      chatBox.scrollTop = chatBox.scrollHeight;
    }
 
    socket.on("chat", (msg)=>{ addChat(msg); pushOverlay(msg); });

    // ===== CHAT OVERLAY + EMOJI QUICK BAR ===== // CHAT OVERLAY
    const chatOverlay = document.getElementById("chatOverlay");
    function pushOverlay(msg){
      if (!chatOverlay) return;
      const role = String(msg.role || "viewer");
      const tag = role === "host" ? "[HOST]" : role === "guest" ? "[GUEST]" : "";
      const el = document.createElement("div");
      el.className = "chat-bubble chat-" + role;
      el.textContent = `${tag ? tag + " " : ""}${msg.name}: ${msg.text}`;
      chatOverlay.appendChild(el);

      // keep only last 4 bubbles
      while (chatOverlay.children.length > 4) chatOverlay.removeChild(chatOverlay.firstChild);

      // auto fade + remove
      setTimeout(() => el.classList.add("hide"), 2600);
      setTimeout(() => { try { el.remove(); } catch {} }, 3200);
    }

    // add emoji buttons
    const emojiBar = document.getElementById("emojiBar");
    if (emojiBar) {
      emojiBar.addEventListener("click", (e) => {
        const btn = e.target.closest("[data-emoji]");
        if (!btn) return;
        const em = btn.getAttribute("data-emoji") || "";
        chatText.value = (chatText.value || "") + em;
        chatText.focus();
      });
    }


    chatSend.onclick = () => {
      const name = (chatName.value || "Viewer").trim();
      const text = chatText.value.trim();
      if (!text) return;

      socket.emit("chat", { roomId, name, text, role: "viewer" });
      chatText.value = "";
    };

    const viewerCountViewer = document.getElementById("viewerCountViewer");


const joinOverlayViewer = document.getElementById("joinOverlayViewer");
function pushJoinViewer(text){
  if (!joinOverlayViewer) return;
  const el = document.createElement("div");
  el.className = "join-bubble";
  el.textContent = text;
  joinOverlayViewer.appendChild(el);
  while (joinOverlayViewer.children.length > 3) joinOverlayViewer.removeChild(joinOverlayViewer.firstChild);
  setTimeout(()=>el.classList.add("hide"), 1400);
  setTimeout(()=>{ try{el.remove();}catch{} }, 2000);
}
socket.on("viewer-join", ({ id }) => {
  pushJoinViewer("â• CÃ³ ngÆ°á»i vÃ o xem");
});
socket.on("viewer-leave", ({ id }) => {
  pushJoinViewer("â– CÃ³ ngÆ°á»i rá»i");
});

socket.on("viewer-count", ({ count }) => {
  if (viewerCountViewer) {
    viewerCountViewer.textContent = `ğŸ‘: ${count}`;
  
    try { viewerCountViewer.classList.remove("pulse"); void viewerCountViewer.offsetWidth; viewerCountViewer.classList.add("pulse"); } catch {}}
});


function swapStreams(){
  const hostStream = player.srcObject;
  const guestStream = guestPlayer.srcObject;
  if (!hostStream || !guestStream) return;

  // Ä‘á»•i stream
  player.srcObject = guestStream;
  guestPlayer.srcObject = hostStream;

  swapped = !swapped;
  document.body.classList.toggle("swap-live", swapped);
}

if (guestPipWrap) {
  guestPipWrap.addEventListener("click", () => {
    swapStreams();
  });
}

  </script>
</body>
</html>
