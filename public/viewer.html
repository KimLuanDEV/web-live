<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Viewer</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1> ğŸ‘ Viewer</h1>
      
      <hr />

      <div class="row">
        <div class="card">
          <div class="kv">
            <div class="badge">PhÃ²ng Livestream</div>
            <code id="roomCode">-</code>

            <div class="badge" id="statusBadge">â³ Äang chá»...</div>

            <button id="btnJoin">Tham gia xem Livestream</button>
          </div>

<button id="btnRequestLive" style="margin-top:10px">ğŸ¤ Xin lÃªn live</button>
<small id="reqTip" style="display:block;opacity:.8;margin-top:6px">
  Báº¥m Ä‘á»ƒ má»Ÿ trang KhÃ¡ch vÃ  gá»­i yÃªu cáº§u lÃªn Host.
</small>

          <hr />
          <div class="log" id="log" style="display: none;"></div>
        </div>

        <div class="card">
         <div class="video-card" style="margin-top:10px">
  <div class="live-overlay">
    <span class="dot"></span>
    <b>LIVE</b>
    
  </div>

<div class="viewer-count" id="viewerCountViewer"> ğŸ‘: 0</div>

<div class="pin-overlay" id="pinOverlay" hidden></div>

<div class="chat-overlay" id="chatOverlay"></div>

  <div class="video-card__inner">
    <video id="player" autoplay playsinline controls></video>
  </div>
</div>
<hr />
<div class="badge badge--info">ğŸ‘¤ KhÃ¡ch má»i</div>
<div class="video-card" style="margin-top:10px">
  <div class="video-card__inner">
    <video id="guestPlayer" autoplay playsinline controls></video>
  </div>
</div>

        </div>
      </div>
    </div>
  </div>

<hr />
<div class="card chat">
  <div class="badge badge--info">ğŸ’¬ Chat (Live)</div>

  <div class="chatform">
    <input id="chatName" placeholder="TÃªn cá»§a báº¡n" />
    <input id="chatText" placeholder="Nháº­p tin nháº¯n..." />
    <button id="chatSend" class="full">Gá»­i</button>
  </div>

  <div class="emoji-bar" id="emojiBar">
    <button type="button" class="emoji-btn" data-emoji="â¤ï¸">â¤ï¸</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ”¥">ğŸ”¥</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ˜‚">ğŸ˜‚</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ˜®">ğŸ˜®</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ˜¢">ğŸ˜¢</button>
  </div>


  <div id="chatBox" class="chatbox"></div>
</div>



  <script src="/socket.io/socket.io.js"></script>
  <script>
    const logEl = document.getElementById("log");
    const badge = document.getElementById("statusBadge");
    const player = document.getElementById("player");
    const guestPlayer = document.getElementById("guestPlayer");
    const btnJoin = document.getElementById("btnJoin");

    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || "abc123";
    document.getElementById("roomCode").textContent = roomId;

    const socket = io();
    let joined = false;

    // multiple peer connections: broadcaster + guest
    const pcs = new Map(); // peerId -> RTCPeerConnection
    let guestId = null;

    async function getRtcConfig() {
      const fallback = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

      try {
        const r = await fetch("/ice", { cache: "no-store" });
        if (!r.ok) return fallback;

        const data = await r.json();
        if (!data.iceServers || !Array.isArray(data.iceServers)) return fallback;

        // Remove invalid STUN urls that contain ?transport=
        const cleanedIceServers = data.iceServers
          .map(server => {
            let urls = server.urls;
            if (!urls) return null;
            if (!Array.isArray(urls)) urls = [urls];

            const safeUrls = urls.filter(u =>
              typeof u === "string" &&
              !(u.startsWith("stun:") && u.includes("?transport="))
            );
            if (safeUrls.length === 0) return null;
            return { ...server, urls: safeUrls };
          })
          .filter(Boolean);

        if (cleanedIceServers.length === 0) return fallback;
        return { iceServers: cleanedIceServers };
      } catch (e) {
        console.error("ICE fetch error:", e);
        return fallback;
      }
    }

    function log(msg) {
      logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

    const liveStatusText = document.getElementById("liveStatusText");
    function setStatus(text) {
      badge.textContent = text;
      if (liveStatusText) liveStatusText.textContent = text.replace(/^[^ ]+\s*/, "");
    }

    socket.on("broadcaster-online", () => setStatus("âœ… Host online"));
    socket.on("broadcaster-offline", () => setStatus("â›” Host offline"));
    socket.on("broadcaster-changed", () => {
      setStatus("ğŸ”„ Host changed â€“ hÃ£y báº¥m Join láº¡i");
      cleanupAll();
    });

    // guest events
    socket.on("guest-online", ({ guestId: gid }) => {
      guestId = gid;
      log("Guest online: " + gid);
      setStatus("ğŸŸ¢ CÃ³ Guest cÃ¹ng live");
      // request guest to stream to this viewer
      socket.emit("watch-guest", { roomId });
    });

    socket.on("guest-offline", () => {
      log("Guest offline");
      guestId = null;
      guestPlayer.srcObject = null;
      // close guest pc if exists
      cleanupPeer("guest");
    });

    async function join() {
      if (joined) return;
      joined = true;
      socket.emit("join-room", { roomId, role: "viewer" });
      setStatus("â³ Äang chá» Host gá»­i LIVE...");
      log("ÄÃ£ join room, Ä‘á»£i offer tá»« host/guest...");
    }

    function cleanupPeer(peerKey) {
      // peerKey can be actual peerId or "guest"
      if (peerKey === "guest") {
        // find by guestId if present
        if (guestId && pcs.has(guestId)) {
          try { pcs.get(guestId).close(); } catch {}
          pcs.delete(guestId);
        }
        return;
      }
      const pc = pcs.get(peerKey);
      if (pc) {
        try { pc.close(); } catch {}
        pcs.delete(peerKey);
      }
    }

    function cleanupAll() {
      for (const pc of pcs.values()) {
        try { pc.close(); } catch {}
      }
      pcs.clear();
      player.srcObject = null;
      guestPlayer.srcObject = null;
      joined = false;
    }

    // Receive offer from broadcaster OR guest
    socket.on("offer", async ({ from, description }) => {
      // reset pc for this peer only
      cleanupPeer(from);

      const rtcConfig = await getRtcConfig();
      const pc = new RTCPeerConnection(rtcConfig);
      pcs.set(from, pc);

      pc.ontrack = (event) => {
        const stream = event.streams[0];

        if (guestId && from === guestId) {
          guestPlayer.srcObject = stream;
          log("ÄÃ£ nháº­n stream GUEST.");
          guestPlayer.play().catch(() => log("Autoplay bá»‹ cháº·n, báº¥m Play á»Ÿ video Guest."));
        } else {
          player.srcObject = stream;
          log("ÄÃ£ nháº­n stream HOST.");
          player.play().catch(() => log("Autoplay bá»‹ cháº·n, báº¥m Play á»Ÿ video Host."));
        }

        setStatus("ğŸŸ¢ Äang xem LIVE");
      };

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          socket.emit("candidate", { to: from, candidate: e.candidate });
        }
      };

      pc.oniceconnectionstatechange = () => {
        log(`ICE(${from}): ${pc.iceConnectionState}`);
      };

      try {
        await pc.setRemoteDescription(description);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("answer", { to: from, description: pc.localDescription });
        setStatus("ğŸŸ¢ Äang xem live trá»±c tiáº¿p.");
        log("ÄÃ£ gá»­i answer cho: " + from);
      } catch (err) {
        log("Lá»—i xá»­ lÃ½ offer: " + err.message);
      }
    });

    socket.on("candidate", async ({ from, candidate }) => {
      const pc = pcs.get(from);
      if (!pc) return;
      try {
        await pc.addIceCandidate(candidate);
      } catch (err) {
        log("Lá»—i addIceCandidate: " + err.message);
      }
    });

    btnJoin.onclick = () => {
      join().catch(err => log("Join lá»—i: " + err.message));
    };

// ===== REQUEST TO GO LIVE (VIEWER -> GUEST) =====
const btnRequestLive = document.getElementById("btnRequestLive");

// máº·c Ä‘á»‹nh disable khi host chÆ°a online
btnRequestLive.disabled = true;

btnRequestLive.onclick = () => {
  const url = `/guest.html?room=${encodeURIComponent(roomId)}`;
  // má»Ÿ tab má»›i Ä‘á»ƒ váº«n xem Ä‘Æ°á»£c live
  window.open(url, "_blank");
};

// chá»‰ cho xin lÃªn live khi broadcaster online
socket.on("broadcaster-online", () => {
  btnRequestLive.disabled = false;
});

socket.on("broadcaster-offline", () => {
  btnRequestLive.disabled = true;
});



    // ===== CHAT (VIEWER) =====
    const chatBox = document.getElementById("chatBox");
    const chatName = document.getElementById("chatName");
    const chatText = document.getElementById("chatText");
    const chatSend = document.getElementById("chatSend");

    function roleLabel(role){
      if (role === "broadcaster") return "HOST";
      if (role === "guest") return "GUEST";
      return "VIEWER";
    }
    function roleClass(role){
      if (role === "broadcaster") return "role-host";
      if (role === "guest") return "role-guest";
      return "role-viewer";
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }



    
    function addChat(msg) {
      const time = new Date(msg.ts).toLocaleTimeString();
      const line = document.createElement("div");
      line.className = "chatline";

      const meta = document.createElement("span");
      meta.className = "chatline__meta " + roleClass(msg.role);
      meta.textContent = `[${time}] ${roleLabel(msg.role)} â€¢ ${msg.name}: `;

      const text = document.createElement("span");
      text.className = "chatline__text";
      text.textContent = msg.text;

      line.appendChild(meta);
      line.appendChild(text);

      // host can pin/unpin
      if (false) {
        const pinBtn = document.createElement("button");
        pinBtn.className = "pin-btn";
        pinBtn.type = "button";
        pinBtn.textContent = "ğŸ“Œ";
        pinBtn.title = "Ghim tin nháº¯n lÃªn video";
        pinBtn.onclick = () => socket.emit("chat-pin", { roomId, msg });
        line.appendChild(pinBtn);
      }

      chatBox.appendChild(line);
      chatBox.scrollTop = chatBox.scrollHeight;
    }
 
    socket.on("chat", (msg)=>{ addChat(msg); pushOverlay(msg); });

    // pinned message (room-wide)
    const pinOverlay = document.getElementById("pinOverlay");
    socket.on("chat-pinned", ({ msg }) => {
      if (!pinOverlay) return;
      if (!msg) {
        pinOverlay.hidden = true;
        pinOverlay.innerHTML = "";
        return;
      }
      pinOverlay.hidden = false;
      pinOverlay.className = "pin-overlay " + roleClass(msg.role);
      pinOverlay.innerHTML = `<b>ğŸ“Œ ${roleLabel(msg.role)} â€¢ ${msg.name}:</b> <span>${escapeHtml(msg.text)}</span>`;
    });


    // ===== CHAT OVERLAY + EMOJI QUICK BAR ===== // CHAT OVERLAY
    const chatOverlay = document.getElementById("chatOverlay");
    
    function pushOverlay(msg){
      if (!chatOverlay) return;
      const el = document.createElement("div");
      el.className = "chat-bubble " + roleClass(msg.role);
      el.textContent = `${roleLabel(msg.role)} â€¢ ${msg.name}: ${msg.text}`;
      chatOverlay.appendChild(el);

      while (chatOverlay.children.length > 4) chatOverlay.removeChild(chatOverlay.firstChild);

      setTimeout(() => el.classList.add("hide"), 2600);
      setTimeout(() => { try { el.remove(); } catch {} }, 3200);
    }

    // add emoji buttons
    const emojiBar = document.getElementById("emojiBar");
    if (emojiBar) {
      emojiBar.addEventListener("click", (e) => {
        const btn = e.target.closest("[data-emoji]");
        if (!btn) return;
        const em = btn.getAttribute("data-emoji") || "";
        chatText.value = (chatText.value || "") + em;
        chatText.focus();
      });
    }


    chatSend.onclick = () => {
      const name = (chatName.value || "KhÃ¡ch").trim();
      const text = chatText.value.trim();
      if (!text) return;

      // client-side spam filter
      const now = Date.now();
      window.__chatAntiSpam = window.__chatAntiSpam || { lastTs: 0, lastText: "", burstStart: 0, burstCount: 0 };
      const s = window.__chatAntiSpam;

      if (now - s.lastTs < 650) return;                // too fast
      if (s.lastText === text && now - s.lastTs < 5000) return;  // repeat
      if (!s.burstStart || now - s.burstStart > 10000) { s.burstStart = now; s.burstCount = 0; }
      s.burstCount++;
      if (s.burstCount > 6) return; // too many in 10s

      s.lastTs = now;
      s.lastText = text;

      socket.emit("chat", { roomId, name, text });
      chatText.value = "";
    };

    const viewerCountViewer = document.getElementById("viewerCountViewer");

socket.on("viewer-count", ({ count }) => {
  if (viewerCountViewer) {
    viewerCountViewer.textContent = `ğŸ‘: ${count}`;
  }
});

  </script>
</body>
</html>
