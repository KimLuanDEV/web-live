<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Guest</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>ğŸ¤ Guest (Xin lÃªn live)</h1>
      <small>Má»Ÿ link nÃ y Ä‘á»ƒ báº­t camera/mic vÃ  xin host cho lÃªn live.</small>
      <hr />

      <div class="badge">Room: <code id="roomCode">-</code></div>
      <div class="badge" id="st" style="margin-top:10px">â³ ChÆ°a báº­t cam</div>

      <hr />
      <button id="btnStart">Báº­t camera + mic & Xin lÃªn live</button>

      <div class="row" style="margin-top:14px">
        <div class="card">
          <div class="badge">Báº¡n</div>
          <div class="video-wrap" style="margin-top:10px">
            <video id="me" autoplay playsinline muted></video>
          </div>
        </div>
        <div class="card">
          <div class="badge">Host (xem Ä‘á»ƒ trÃ² chuyá»‡n)</div>
          <div class="video-wrap" style="margin-top:10px">
            <video id="hostVideo" autoplay playsinline controls></video>
          </div>
        </div>
      </div>
    </div>
  </div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();
  const params = new URLSearchParams(location.search);
  const roomId = params.get("room") || "abc123";
  document.getElementById("roomCode").textContent = roomId;

  const st = document.getElementById("st");
  const me = document.getElementById("me");
  const hostVideo = document.getElementById("hostVideo");
  const btnStart = document.getElementById("btnStart");

  let localStream = null;
  const pcs = new Map(); // peer per viewer/host

  async function getRtcConfig() {
    const fallback = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
    try {
      const r = await fetch("/ice", { cache: "no-store" });
      if (!r.ok) return fallback;
      const data = await r.json();
      if (!data.iceServers || !Array.isArray(data.iceServers)) return fallback;

      // lá»c stun twilio lá»—i '?transport=' (phÃ²ng há»)
      const cleaned = data.iceServers.map(s => {
        let urls = s.urls;
        if (!Array.isArray(urls)) urls = [urls];
        urls = urls.filter(u => !(typeof u === "string" && u.startsWith("stun:") && u.includes("?transport=")));
        return { ...s, urls };
      }).filter(s => s.urls && (Array.isArray(s.urls) ? s.urls.length : true));

      return { iceServers: cleaned.length ? cleaned : fallback.iceServers };
    } catch { return fallback; }
  }

  btnStart.onclick = async () => {
    if (localStream) return;
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
      me.srcObject = localStream;
      st.textContent = "â³ ÄÃ£ báº­t cam. Äang chá» host duyá»‡t...";

      socket.emit("join-room", { roomId, role: "guest" });
    } catch (e) {
      alert("KhÃ´ng má»Ÿ Ä‘Æ°á»£c camera/mic: " + e.message);
    }
  };

  socket.on("guest-pending", () => st.textContent = "â³ Äang chá» host duyá»‡t...");
  socket.on("guest-rejected", () => st.textContent = "â›” Host tá»« chá»‘i.");
  socket.on("guest-approved", () => st.textContent = "âœ… ÄÆ°á»£c duyá»‡t! NgÆ°á»i xem sáº½ tháº¥y báº¡n.");

  // Khi cÃ³ viewer/host muá»‘n xem guest => guest táº¡o offer cho há»
  socket.on("guest-watcher", async ({ viewerId }) => {
    if (!localStream) return;
    if (pcs.has(viewerId)) return;

    const rtc = await getRtcConfig();
    const pc = new RTCPeerConnection(rtc);
    pcs.set(viewerId, pc);

    localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

    pc.onicecandidate = (e) => {
      if (e.candidate) socket.emit("candidate", { to: viewerId, candidate: e.candidate });
    };

    // guest nháº­n láº¡i audio/video tá»« host (náº¿u host gá»­i)
    pc.ontrack = (e) => {
      // track tá»« host sáº½ vÃ o Ä‘Ã¢y (khi host addTrack)
      hostVideo.srcObject = e.streams[0];
    };

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.emit("offer", { to: viewerId, description: pc.localDescription });
  });

  socket.on("answer", async ({ from, description }) => {
    const pc = pcs.get(from);
    if (!pc) return;
    await pc.setRemoteDescription(description);
  });

  socket.on("candidate", async ({ from, candidate }) => {
    const pc = pcs.get(from);
    if (!pc) return;
    try { await pc.addIceCandidate(candidate); } catch {}
  });

  window.addEventListener("beforeunload", () => {
    for (const pc of pcs.values()) try { pc.close(); } catch {}
    if (localStream) localStream.getTracks().forEach(t => t.stop());
  });
</script>
</body>
</html>
