<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta
  name="viewport"
  content="width=device-width,
           initial-scale=1,
           maximum-scale=1,
           minimum-scale=1,
           user-scalable=no"
/>

  <title>Guest - Livestream Pro</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>ğŸ‘¤ KhÃ¡ch má»i</h1>
      <hr />

      <div class="row">
        <div class="card">
          <div class="kv">
            <div class="badge">PhÃ²ng Livestream</div>
            <code id="roomCode">-</code>

            <div class="badge" id="statusBadge">â³ ChÆ°a báº­t cam/mic</div>
            
          </div>

         

          <hr />
          <div class="log" id="log" style="display: none;"></div>
        </div>

        <div class="card">

          <!-- âœ… LIVE STAGE: HOST MAIN + ME PIP -->
          <div class="live-stage" id="liveStageGuest" style="margin-top:10px">

<!-- ğŸ GIFT FLOATING -->
<div id="giftFab" class="gift-fab">ğŸ</div>

<div id="giftPanel" class="gift-panel hidden">
  <div class="gift-header">
    <span>ğŸ QuÃ  táº·ng</span>
    <button id="giftClose">âœ•</button>
  </div>
  <div id="giftGrid" class="gift-grid"></div>
</div>



            <div class="gift-layer" id="giftLayer"></div>

            <!-- HOST MAIN -->
            <div class="video-card live-main" id="hostCardGuest">
              <div class="live-overlay">
                <span class="dot"></span>
                <b>HOST</b>
                <span class="live-meta">
                  <span class="meta-item" id="liveTimerGuest">â± 00:00:00</span>
                </span>
              </div>

              <div class="chat-overlay" id="chatOverlay"></div>

              <!-- CHAT QUICK BUTTON -->
<button class="chat-fab" id="chatFab">ğŸ’¬</button>

<!-- CHAT INPUT OVERLAY -->
<div class="chat-input-overlay hidden" id="chatInputOverlay">
  <input
    id="quickChatInput"
    placeholder="Nháº­p tin nháº¯n..."
    autocomplete="off"
  />
  <button id="quickChatSend">â¤</button>
</div>


<div class="pin-overlay" id="pinOverlay"></div>

                  <div class="reactions-layer" id="reactionsLayerGuestMain"></div>
<div class="video-card__inner">
                <video id="hostVideo" autoplay playsinline></video>
              </div>
            </div>

            <!-- ME PIP -->
            <div class="pip-wrap" id="mePipWrap" aria-hidden="true" title="Báº¥m Ä‘á»ƒ phÃ³ng to/thu nhá»">
              <div class="pip-badge">ğŸ‘¤ YOU</div>
              <video id="me" autoplay playsinline muted></video>
            </div>
          
            <div class="join-overlay" id="joinOverlayGuest" aria-live="polite"></div>
            <div class="av-overlay" id="avOverlayGuest">
</div>

          
            <div class="ctrl-tab ctrl-tab--stage" id="ctrlTabGuest">
              <button class="ctrl-fab" id="ctrlFabGuest" type="button" aria-expanded="false" title="Má»Ÿ Ä‘iá»u khiá»ƒn">â˜°</button>
              <div class="ctrl-drawer" id="ctrlDrawerGuest" hidden>
                <div class="ctrl-title">ğŸ› Äiá»u khiá»ƒn</div>
                <div class="ctrl-grid">
                  <button id="btnStart" class="av-btn" title="Xin lÃªn live">ğŸ¤</button>
                  <button id="btnLeaveLive" class="av-btn" title="Rá»i live" disabled>ğŸšª</button>

                  <button id="guestMicBtn" class="av-btn" title="Báº­t / Táº¯t mic">ğŸ™ï¸</button>
                  <button id="guestCamBtn" class="av-btn" title="Báº­t / Táº¯t camera">ğŸ“·</button>
                  <button id="guestFlipBtn" class="av-btn" title="Äáº£o camera" disabled>ğŸ”„</button>
                </div>
                <div class="ctrl-hint">Nháº¥n â˜° Ä‘á»ƒ thu gá»n</div>
              </div>
            </div>
</div>
          <!-- /LIVE STAGE -->
             


        </div>
      </div>
    </div>
  </div>

  <hr />
  <div class="card chat">
    <div class="badge badge--info">ğŸ’¬ Chat (Live)</div>

    <div class="chatform">
      <input id="chatName" value="KhÃ¡ch" />
      <input id="chatText" placeholder="Nháº­p tin nháº¯n..." />
      <button id="chatSend" class="full">Gá»­i</button>
    </div>

    <div class="emoji-bar" id="emojiBar" style="display: none;">
      <button type="button" class="emoji-btn" data-emoji="â¤ï¸">â¤ï¸</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ”¥">ğŸ”¥</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ˜‚">ğŸ˜‚</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ˜®">ğŸ˜®</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ˜¢">ğŸ˜¢</button>
    </div>

  <div class="gift-bar">
  <button data-gift="heart">â¤ï¸</button>
  <button data-gift="flower">ğŸŒ¸</button>
  <button data-gift="rocket">ğŸš€</button>
  <button data-gift="coin">ğŸ’°</button>
  <button data-gift="dragon">ğŸ‰</button>
  <button data-gift="phoenix">ğŸ¦…</button>
  <button data-gift="galaxy">ğŸŒŒ</button>
  <button data-gift="meteor">â˜„ï¸</button>
  <button data-gift="king">ğŸ‘‘</button>
  <button data-gift="dragonking">ğŸ²</button>
  <button data-gift="supernova">ğŸŒ </button>
</div>

</div>

<div class="gift-wallet">
  <div class="gift-wallet__row">
    <span class="gift-wallet__label">VÃ­ coin:</span>
    <b id="walletCoins">0</b>
    <span class="gift-wallet__unit">coin</span>
  </div>
  <div class="gift-wallet__row gift-wallet__row--small">
    <span class="gift-wallet__hint">Má»—i quÃ  trá»« coin â€¢ dÃ¹ng Ä‘á»ƒ test Gift Engine</span>
  </div>
  <div class="gift-combo" id="giftCombo">
    <span class="gift-combo__label">Combo:</span>
    <button type="button" class="gift-combo__btn is-active" data-combo="1">x1</button>
    <button type="button" class="gift-combo__btn" data-combo="5">x5</button>
    <button type="button" class="gift-combo__btn" data-combo="10">x10</button>
  </div>

  <div class="gift-board">
    <div class="gift-board__head">ğŸ† Top donate</div>
    <div class="gift-board__meta">Tá»•ng: <b id="giftTotalCoins">0</b> coin</div>
    <div id="giftTopList" class="gift-board__list"></div>
  </div>
</div>



    <div id="chatBox" class="chatbox"></div>
  </div>


  
<!-- NEON CONFIRM (Back to Lobby) -->
<div id="neonConfirm" class="ncf hidden" aria-hidden="true">
  <div class="ncf__bg"></div>

  <div class="ncf__box" role="dialog" aria-modal="true" aria-labelledby="ncfTitle">
    <div class="ncf__frame"></div>
    <div class="ncf__scan"></div>

    <div class="ncf__top">
      <div class="ncf__pill">
        <span class="ncf__dot"></span>
        <span>Rá»œI PHÃ’NG XEM</span>
      </div>
      <button class="ncf__x" id="ncfX" type="button" aria-label="ÄÃ³ng">âœ•</button>
    </div>

    <h3 id="ncfTitle" class="ncf__title">Quay vá» Lobby?</h3>

    <div class="ncf__desc">
      <div class="ncf__row">â€¢ Báº¡n sáº½ rá»i khá»i phÃ²ng Ä‘ang xem</div>
      <div class="ncf__row">â€¢ CÃ³ thá»ƒ vÃ o láº¡i tá»« Lobby báº¥t ká»³ lÃºc nÃ o</div>
    </div>

    <div class="ncf__actions">
      <button id="ncfCancel" class="ncf__btn ncf__btn--ghost" type="button">á» láº¡i</button>
      <button id="ncfOk" class="ncf__btn ncf__btn--main" type="button">âœ… Vá» Lobby</button>
    </div>
  </div>
</div>


  <script src="/socket.io/socket.io.js"></script>
  <script>
    const logEl = document.getElementById("log");
    const badge = document.getElementById("statusBadge");
    const me = document.getElementById("me");
    const hostVideo = document.getElementById("hostVideo");
    const btnStart = document.getElementById("btnStart");
    const btnLeaveLive = document.getElementById("btnLeaveLive");
    const guestFlipBtn = document.getElementById("guestFlipBtn");
    

    // PIP elements
    const mePipWrap = document.getElementById("mePipWrap");

    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || "abc123";
    document.getElementById("roomCode").textContent = roomId;

    const socket = io();
    


// ===== VIP TICKER + CHAT FREEZE + FIREWORKS =====
const vipTicker = document.getElementById("vipTicker");
let __vipQueue = [];
let __vipBusy = false;

function showVipTicker(text, ms){
  try{
    if (!vipTicker) return;
    const item = document.createElement("div");
    item.className = "vip-ticker__item";
    item.textContent = text;
    vipTicker.appendChild(item);
    // auto remove after animation
    setTimeout(()=>{ try{ item.classList.add("hide"); }catch{} }, Math.max(0, ms-350));
    setTimeout(()=>{ try{ item.remove(); }catch{} }, ms+200);
  }catch{}
}

function enqueueVip(text, ms=3000){
  __vipQueue.push({ text, ms });
  if (!__vipBusy) runVipQueue();
}

function runVipQueue(){
  if (__vipBusy) return;
  const next = __vipQueue.shift();
  if (!next) return;
  __vipBusy = true;
  showVipTicker(next.text, next.ms);
  setTimeout(()=>{
    __vipBusy = false;
    runVipQueue();
  }, next.ms + 120);
}

function freezeChat(ms=1000){
  try{
    document.body.classList.add("chat-frozen");
    setTimeout(()=>{ try{document.body.classList.remove("chat-frozen");}catch{} }, ms);
  }catch{}
}

function startVipSpotlight(ms=1200){
  try{
    // add overlay class
    document.body.classList.add("vip-spotlight");
    // zoom main card if exists
    const card = document.getElementById("hostCard") || document.getElementById("hostCardGuest");
    if (card) card.classList.add("vip-zoom");
    // remove
    setTimeout(()=>{
      try{
        document.body.classList.remove("vip-spotlight");
        if (card) card.classList.remove("vip-zoom");
      }catch{}
    }, ms);
  }catch{}
}

function spawnFireworksBurst(){
  try{
    const layer = document.createElement("div");
    layer.className = "vip-fireworks";
    document.body.appendChild(layer);

    const n = 18;
    for (let i=0;i<n;i++){
      const p = document.createElement("div");
      p.className = "vip-fireworks__p";
      p.style.left = (50 + (Math.random()*18-9))+"%";
      p.style.top  = (22 + (Math.random()*18-9))+"%";
      p.style.setProperty("--dx", (Math.random()*360-180)+"px");
      p.style.setProperty("--dy", (Math.random()*340-220)+"px");
      p.style.setProperty("--rot",(Math.random()*160-80)+"deg");
      p.style.setProperty("--sc",(Math.random()*0.9+0.7));
      layer.appendChild(p);
    }

    setTimeout(()=>{ try{layer.remove();}catch{} }, 1600);
  }catch{}
}
// ===== /VIP TICKER =====
// ===== AUTO SPEAKING HIGHLIGHT (Voice Activity) =====
function attachSpeakingIndicator(videoEl, targetEl){
  try{
    if (!videoEl || !targetEl) return;
    let ctx = null, src = null, analyser = null, data = null, raf = 0;
    let speaking = false;
    let lastOn = 0;

    function start(){
      const st = videoEl.srcObject;
      if (!st) return;
      const at = st.getAudioTracks && st.getAudioTracks()[0];
      if (!at) return; // no audio -> skip

      ctx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = ctx.createAnalyser();
      analyser.fftSize = 512;
      data = new Uint8Array(analyser.frequencyBinCount);

      src = ctx.createMediaStreamSource(new MediaStream([at]));
      src.connect(analyser);

      const TH = 16; // threshold 0..255 (tuning)
      const HOLD_MS = 450;

      const loop = ()=>{
        if (!analyser) return;
        analyser.getByteFrequencyData(data);
        let sum = 0;
        for (let i=0;i<data.length;i++) sum += data[i];
        const avg = sum / data.length;

        const now = Date.now();
        if (avg > TH){
          lastOn = now;
          if (!speaking){
            speaking = true;
            targetEl.classList.add("is-speaking");
          }
        } else {
          if (speaking && (now - lastOn) > HOLD_MS){
            speaking = false;
            targetEl.classList.remove("is-speaking");
          }
        }
        raf = requestAnimationFrame(loop);
      };
      raf = requestAnimationFrame(loop);
    }

    function stop(){
      try{ if (raf) cancelAnimationFrame(raf); }catch{}
      raf = 0;
      try{ targetEl.classList.remove("is-speaking"); }catch{}
      speaking = false;
      try{ if (src) src.disconnect(); }catch{}
      src = null;
      try{ if (ctx) ctx.close(); }catch{}
      ctx = null;
      analyser = null;
      data = null;
    }

    // restart when stream changes
    const _set = ()=>{
      stop();
      start();
    };

    // run now + also after play
    _set();
    videoEl.addEventListener("loadedmetadata", _set);
    videoEl.addEventListener("play", _set);

    // expose for manual cleanup
    videoEl.__stopSpeakingIndicator = stop;
  }catch(e){
    console.warn("attachSpeakingIndicator error:", e);
  }
}
// ===== /AUTO SPEAKING HIGHLIGHT =====

// ===== CTRL TAB (collapse/expand) =====
    (function initCtrlTabGuest(){
      const fab = document.getElementById("ctrlFabGuest");
      const drawer = document.getElementById("ctrlDrawerGuest");
      const tab = document.getElementById("ctrlTabGuest");
      if (!fab || !drawer || !tab) return;

      function open(){
        drawer.hidden = false;
        tab.classList.add("is-open");
        fab.setAttribute("aria-expanded","true");
      }
      function close(){
        tab.classList.remove("is-open");
        fab.setAttribute("aria-expanded","false");
        setTimeout(()=>{ drawer.hidden = !tab.classList.contains("is-open"); }, 160);
      }
      function toggle(){ tab.classList.contains("is-open") ? close() : open(); }

      fab.addEventListener("click", (e)=>{ e.stopPropagation(); toggle(); });
      document.addEventListener("click", (e)=>{
        if (!tab.classList.contains("is-open")) return;
        if (tab.contains(e.target)) return;
        close();
      });
      document.addEventListener("keydown", (e)=>{
        if (e.key === "Escape" && tab.classList.contains("is-open")) close();
      });
    })();
    // ===== /CTRL TAB =====


// ===== VIEWER JOIN/LEAVE TOAST =====
const joinOverlayGuest = document.getElementById("joinOverlayGuest");
function pushJoinGuest(text){
  if (!joinOverlayGuest) return;
  const el = document.createElement("div");
  el.className = "join-bubble";
  el.textContent = text;
  joinOverlayGuest.appendChild(el);
  while (joinOverlayGuest.children.length > 3) joinOverlayGuest.removeChild(joinOverlayGuest.firstChild);
  setTimeout(()=>el.classList.add("hide"), 1400);
  setTimeout(()=>{ try{el.remove();}catch{} }, 2000);
}
socket.on("viewer-join", () => pushJoinGuest("â• +1 ngÆ°á»i xem"));
socket.on("viewer-leave", () => pushJoinGuest("â– -1 ngÆ°á»i xem"));
// ===== /VIEWER JOIN/LEAVE TOAST =====
// ===== PIN NOTE (display only) =====
const pinOverlay = document.getElementById("pinOverlay");
function __clamp01(n){ n = Number(n); if (!isFinite(n)) return 0.5; return Math.max(0, Math.min(1, n)); }
function renderPin(note){
  if (!pinOverlay) return;
  pinOverlay.innerHTML = "";
  if (!note) return;
  const wrap = document.createElement("div");
  wrap.className = "pin-note";
  wrap.style.left = (__clamp01(note.x) * 100).toFixed(3) + "%";
  wrap.style.top  = (__clamp01(note.y) * 100).toFixed(3) + "%";

  const head = document.createElement("div");
  head.className = "pin-head";
  const title = document.createElement("div");
  title.className = "pin-title";
  title.innerHTML = ``;
  head.appendChild(title);

  const body = document.createElement("div");
  body.className = "pin-body";
  body.textContent = String(note.text || "");

  wrap.appendChild(head);
  wrap.appendChild(body);
  pinOverlay.appendChild(wrap);
}
socket.on("pin-note-update", (note)=> renderPin(note));
// ===== /PIN NOTE =====


// ===== PER-PEER ICE RESTART (auto) =====
const __iceRestartState = new Map(); // peerId -> { timer, lastTs, restarting }
function __now(){ return Date.now(); }
function __clearIceTimer(peerId){
  const st = __iceRestartState.get(peerId);
  if (st && st.timer) { clearTimeout(st.timer); st.timer = null; }
}
async function __doIceRestart(peerId, pc, reason){
  if (!peerId || !pc) return;
  if (pc.signalingState === "closed") return;

  const st = __iceRestartState.get(peerId) || { timer:null, lastTs:0, restarting:false };
  // debounce: avoid spamming offers
  const ts = __now();
  if (st.restarting) return;
  if (ts - st.lastTs < 1500) return;

  st.restarting = true;
  st.lastTs = ts;
  __iceRestartState.set(peerId, st);

  try {
    log(`ğŸ§Š ICE restart -> ${peerId} (GUEST) ${reason ? "- " + reason : ""}`);
    const offer = await pc.createOffer({ iceRestart: true });
    await pc.setLocalDescription(offer);
    socket.emit("offer", { to: peerId, description: pc.localDescription, iceRestart: true });
  } catch (e) {
    log("ICE restart error: " + (e?.message || e));
  } finally {
    const st2 = __iceRestartState.get(peerId) || st;
    st2.restarting = false;
    __iceRestartState.set(peerId, st2);
  }
}
function __scheduleIceRestart(peerId, pc, reason, delayMs=2200){
  if (!peerId || !pc) return;
  const st = __iceRestartState.get(peerId) || { timer:null, lastTs:0, restarting:false };
  __clearIceTimer(peerId);
  st.timer = setTimeout(()=>{
    // only restart if still not connected
    const ice = pc.iceConnectionState;
    const cs  = pc.connectionState;
    if (pc.signalingState === "closed") return;
    if (ice === "failed" || ice === "disconnected" || cs === "failed" || cs === "disconnected") {
      __doIceRestart(peerId, pc, reason);
    }
  }, delayMs);
  __iceRestartState.set(peerId, st);
}
function __wireIceAuto(peerId, pc, opts={}){
  if (!pc) return;
  const disconnectedDelay = opts.disconnectedDelay ?? 2500;

  pc.addEventListener("iceconnectionstatechange", () => {
    const st = pc.iceConnectionState;
    log(`ICE(${peerId}): ${st}`);
    if (st === "connected" || st === "completed") {
      __clearIceTimer(peerId);
      return;
    }
    if (st === "failed") {
      __scheduleIceRestart(peerId, pc, "ice failed", 50);
      return;
    }
    if (st === "disconnected") {
      __scheduleIceRestart(peerId, pc, "ice disconnected", disconnectedDelay);
      return;
    }
  });

  pc.addEventListener("connectionstatechange", () => {
    const st = pc.connectionState;
    if (!st) return;
    log(`CS(${peerId}): ${st}`);
    if (st === "connected") __clearIceTimer(peerId);
    if (st === "failed") __scheduleIceRestart(peerId, pc, "conn failed", 50);
    if (st === "disconnected") __scheduleIceRestart(peerId, pc, "conn disconnected", disconnectedDelay);
  });
}

// Restart only peers that are actually bad (NOT all)
function __restartBadPeers(getPeers){
  try {
    const peers = getPeers?.() || [];
    for (const [peerId, pc] of peers) {
      if (!pc || pc.signalingState === "closed") continue;
      const ice = pc.iceConnectionState;
      const cs = pc.connectionState;
      if (ice === "failed" || ice === "disconnected" || cs === "failed" || cs === "disconnected") {
        __doIceRestart(peerId, pc, "auto resume");
      }
    }
  } catch {}
}
// ===== /PER-PEER ICE RESTART =====

// ===== LIVE TIMER (HH:MM:SS) =====
let __liveStartTs = null;
let __liveTick = null;

function __pad2(n){ n = Math.floor(Math.max(0, n)); return String(n).padStart(2,"0"); }
function __fmtHMS(ms){
  const s = Math.floor(ms/1000);
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  const ss = s%60;
  return `${__pad2(hh)}:${__pad2(mm)}:${__pad2(ss)}`;
}
function __setTimerText(el, ms){
  if (!el) return;
  el.textContent = `â± ${__fmtHMS(ms)}`;
}
function __startTimer(el, startTs){
  __liveStartTs = startTs;
  if (__liveTick) clearInterval(__liveTick);
  __setTimerText(el, Date.now() - __liveStartTs);
  __liveTick = setInterval(()=>__setTimerText(el, Date.now() - __liveStartTs), 250);
}
function __stopTimer(el){
  __liveStartTs = null;
  if (__liveTick) clearInterval(__liveTick);
  __liveTick = null;
  if (el) el.textContent = "â± 00:00:00";
}

const liveTimerGuest = document.getElementById("liveTimerGuest");
socket.on("live-start", ({ startTs }) => {
  if (typeof startTs === "number") __startTimer(liveTimerGuest, startTs);
});
socket.on("live-stop", () => {
  __stopTimer(liveTimerGuest);
});


// ===== REACTIONS (tap/click to heart) =====
function clamp01(n){ return Math.max(0, Math.min(1, n)); }
function now(){ return Date.now(); }

function attachTapToHeart(tapEl, layerEl, getRoomIdFn) {
  if (!tapEl || !layerEl) return;
  let last = 0;
  const MIN_MS = 180; // anti-spam client side

  const handler = (ev) => {
    // prevent video click from toggling play/pause
    try { if (ev && ev.cancelable) ev.preventDefault(); } catch {}
    try { ev.stopPropagation(); } catch {}
    // ignore clicks on controls/buttons/inputs
    const t = ev.target;
    if (t && (t.closest("button") || t.closest("input") || t.closest("textarea"))) return;

    const ts = now();
    if (ts - last < MIN_MS) return;
    last = ts;

    const rect = tapEl.getBoundingClientRect();
    const cx = ("clientX" in ev) ? ev.clientX : (ev.touches && ev.touches[0] ? ev.touches[0].clientX : rect.left + rect.width/2);
    const cy = ("clientY" in ev) ? ev.clientY : (ev.touches && ev.touches[0] ? ev.touches[0].clientY : rect.top + rect.height/2);
    const x = clamp01((cx - rect.left) / rect.width);
    const y = clamp01((cy - rect.top) / rect.height);

    const msg = { roomId: getRoomIdFn(), emoji: "â¤ï¸", x, y };
    // show immediately on self
    spawnReaction(layerEl, msg.emoji, msg.x, msg.y, true);
    socket.emit("reaction", msg);
  };

  tapEl.addEventListener("pointerdown", handler, { passive: false });
  // also fallback for old browsers
  tapEl.addEventListener("click", handler);
}

function spawnReaction(layerEl, emoji, x, y, local=false) {
  if (!layerEl) return;
  const el = document.createElement("div");
  el.className = "reaction-float";
  el.textContent = emoji || "â¤ï¸";
  // random motion
  const dx = (Math.random() * 120 - 60).toFixed(1); // px
  const rot = (Math.random() * 30 - 15).toFixed(1); // deg
  const sc = (0.85 + Math.random() * 0.8).toFixed(2);
  el.style.setProperty("--x", String(x));
  el.style.setProperty("--y", String(y));
  el.style.setProperty("--dx", dx + "px");
  el.style.setProperty("--rot", rot + "deg");
  el.style.setProperty("--sc", sc);
  if (local) el.classList.add("is-local");
  layerEl.appendChild(el);
  setTimeout(()=>{ try{ el.remove(); }catch{} }, 1800);
}

socket.on("reaction", (msg)=>{
  try {
    if (!msg) return;
    const emoji = msg.emoji || "â¤ï¸";
    const x = clamp01(Number(msg.x ?? 0.5));
    const y = clamp01(Number(msg.y ?? 0.7));
    // choose layer based on whether it's guest/host layer (we only have one layer per page for now)
    const layer = document.getElementById("reactionsLayerGuestMain");
    spawnReaction(layer, emoji, x, y, false);
  } catch (e) {
    console.warn("reaction render error", e);
  }
});

// ===== INIT TAP-TO-HEART on main live card =====
(function initTapHearts(){
  const __tapEl = document.getElementById("hostCardGuest");
  const __layerEl = document.getElementById("reactionsLayerGuestMain");
  if (!__tapEl || !__layerEl) return;
  attachTapToHeart(__tapEl, __layerEl, ()=>roomId);
})();


    let localStream = null;
    const pcs = new Map(); // peerId -> RTCPeerConnection

    // When network comes back / tab returns, restart only bad peers
    window.addEventListener("online", () => __restartBadPeers(() => Array.from(pcs.entries())));
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") __restartBadPeers(() => Array.from(pcs.entries()));
    });


    // Peer asks GUEST to ICE-restart this connection (GUEST is offerer to watchers)
    socket.on("request-ice-restart", async ({ from, reason }) => {
      const peerId = from;
      const pc = pcs.get(peerId);
      if (pc) __doIceRestart(peerId, pc, reason || "requested");
    });


    let currentFacing = "user"; // user (cam trÆ°á»›c) | environment (cam sau)

    async function getRtcConfig() {
      const fallback = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
      try {
        const r = await fetch("/ice", { cache: "no-store" });
        if (!r.ok) return fallback;
        const data = await r.json();
        if (!data.iceServers || !Array.isArray(data.iceServers)) return fallback;

        const cleanedIceServers = data.iceServers
          .map(server => {
            let urls = server.urls;
            if (!urls) return null;
            if (!Array.isArray(urls)) urls = [urls];
            const safeUrls = urls.filter(u =>
              typeof u === "string" &&
              !(u.startsWith("stun:") && u.includes("?transport="))
            );
            if (safeUrls.length === 0) return null;
            return { ...server, urls: safeUrls };
          })
          .filter(Boolean);

        if (cleanedIceServers.length === 0) return fallback;
        return { iceServers: cleanedIceServers };
      } catch (e) {
        console.error(e);
        return fallback;
      }
    }

    function log(msg) {
      logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }
    function setStatus(t){ badge.textContent = t; }

    btnStart.onclick = async () => {
      if (localStream) return;
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { ideal: currentFacing } },
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        });
        me.srcObject = localStream;

        
    try{ attachSpeakingIndicator(me, document.getElementById('mePipWrap')); }catch{}
// âœ… báº­t PIP (YOU)
        document.body.classList.add("has-guest");
        if (mePipWrap) mePipWrap.setAttribute("aria-hidden", "false");

        socket.emit("join-room", { roomId, role: "guest", profile: { name: (chatName.value||"Guest").trim().slice(0,20), coins: Number(localStorage.getItem("ls_coins")||0) || 0 } });
        setStatus("â³ ÄÃ£ báº­t cam/mic. Äang chá» host duyá»‡t...");
        log("ÄÃ£ xin lÃªn live, chá» host duyá»‡t...");

        btnStart.disabled = true;
        btnLeaveLive.disabled = false;
        guestFlipBtn.disabled = false;
        


      } catch (e) {
        alert("KhÃ´ng má»Ÿ Ä‘Æ°á»£c camera/mic: " + e.message);
      }
    };

    socket.on("guest-pending", () => setStatus("â³ Äang chá» host duyá»‡t..."));
    socket.on("guest-rejected", () => setStatus("â›” Host tá»« chá»‘i."));
    socket.on("guest-approved", () => {
      setStatus("âœ… ÄÆ°á»£c duyá»‡t! Báº¡n Ä‘ang lÃªn live.");
      log("ÄÆ°á»£c duyá»‡t! BÃ¢y giá» viewer/host sáº½ káº¿t ná»‘i tá»›i báº¡n.");
    });

    // When someone wants to watch guest, guest creates offer to them
    socket.on("guest-watcher", async ({ viewerId }) => {
      if (!localStream) return;
      if (pcs.has(viewerId)) return;

      log("Táº¡o káº¿t ná»‘i tá»›i: " + viewerId);

      const rtcConfig = await getRtcConfig();
      const pc = new RTCPeerConnection(rtcConfig);
      pcs.set(viewerId, pc);

      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      pc.onicecandidate = (e) => {
        if (e.candidate) socket.emit("candidate", { to: viewerId, candidate: e.candidate });
      };

      // Receive host stream (host will addTrack when answering)
      pc.ontrack = (e) => {
        hostVideo.srcObject = e.streams[0];
        hostVideo.play().catch(() => {});
      };

            __wireIceAuto(viewerId, pc);

      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit("offer", { to: viewerId, description: pc.localDescription });
      } catch (err) {
        log("Lá»—i táº¡o offer: " + err.message);
      }
    });

    socket.on("answer", async ({ from, description }) => {
      const pc = pcs.get(from);
      if (!pc) return;
      try { await pc.setRemoteDescription(description); }
      catch (err) { log("Lá»—i setRemoteDescription(answer): " + err.message); }
    });

    socket.on("candidate", async ({ from, candidate }) => {
      const pc = pcs.get(from);
      if (!pc) return;
      try { await pc.addIceCandidate(candidate); }
      catch (err) { log("Lá»—i addIceCandidate: " + err.message); }
    });

    // ===== GUEST: FLIP CAMERA + LEAVE LIVE =====
    async function flipCamera() {
      if (!localStream) return;
      currentFacing = (currentFacing === "user") ? "environment" : "user";
      log("ğŸ”„ Äang Ä‘áº£o camera: " + (currentFacing === "user" ? "TRÆ¯á»šC" : "SAU"));

      try {
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { ideal: currentFacing } },
          audio: false
        });
        const newVideoTrack = newStream.getVideoTracks()[0];
        if (!newVideoTrack) throw new Error("KhÃ´ng láº¥y Ä‘Æ°á»£c camera má»›i");

        const oldVideoTrack = localStream.getVideoTracks()[0];
        if (oldVideoTrack) {
          localStream.removeTrack(oldVideoTrack);
          oldVideoTrack.stop();
        }
        localStream.addTrack(newVideoTrack);

        me.srcObject = localStream;

        for (const pc of pcs.values()) {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender) await sender.replaceTrack(newVideoTrack);
          else pc.addTrack(newVideoTrack, localStream);
        }

        log("âœ… Äáº£o camera thÃ nh cÃ´ng");
      } catch (err) {
        currentFacing = (currentFacing === "user") ? "environment" : "user";
        log("âŒ KhÃ´ng Ä‘áº£o Ä‘Æ°á»£c camera: " + err.message);
        alert("KhÃ´ng Ä‘áº£o Ä‘Æ°á»£c camera: " + err.message);
      }
    }

    function leaveLive() {
      log("ğŸšª Rá»i live...");

      for (const pc of pcs.values()) { try { pc.close(); } catch {} }
      pcs.clear();

      if (localStream) {
        try { localStream.getTracks().forEach(t => t.stop()); } catch {}
        localStream = null;
      }

      // âœ… reset UI state
      document.body.classList.remove("has-guest");

      if (mePipWrap) mePipWrap.setAttribute("aria-hidden", "true");

      btnStart.disabled = false;
      btnLeaveLive.disabled = true;
      guestFlipBtn.disabled = true;
      


      try { socket.disconnect(); } catch {}

      location.href = "/viewer.html?room=" + encodeURIComponent(roomId);
    }

    guestFlipBtn.onclick = flipCamera;

    btnLeaveLive.onclick = leaveLive;

    window.addEventListener("beforeunload", () => {
      for (const pc of pcs.values()) { try { pc.close(); } catch {} }
      pcs.clear();
      if (localStream) localStream.getTracks().forEach(t => t.stop());
    });

    // ===== CHAT =====
    const chatBox = document.getElementById("chatBox");
    const chatName = document.getElementById("chatName");
    const chatText = document.getElementById("chatText");
    const chatSend = document.getElementById("chatSend");

    function addChat(msg) {
      const time = new Date(msg.ts).toLocaleTimeString();
      const role = String(msg.role || "viewer");
      const tag = role === "host" ? "[HOST]" : role === "guest" ? "[GUEST]" : "";
      const line = document.createElement("div");
      line.className = "chat-line chat-" + role;
      line.textContent = `[${time}] ${tag ? tag + " " : ""}${msg.name}: ${msg.text}`;
      chatBox.appendChild(line);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    socket.on("chat", (msg)=>{ addChat(msg); pushOverlay(msg); });

    const chatOverlay = document.getElementById("chatOverlay");
    function pushOverlay(msg){
      if (!chatOverlay) return;
      const role = String(msg.role || "viewer");
      const tag = role === "host" ? "[HOST]" : role === "guest" ? "[GUEST]" : "";
      const el = document.createElement("div");
      el.className = "chat-bubble chat-" + role;
      el.textContent = `${tag ? tag + " " : ""}${msg.name}: ${msg.text}`;
      chatOverlay.appendChild(el);

      while (chatOverlay.children.length > 4) chatOverlay.removeChild(chatOverlay.firstChild);

      setTimeout(() => el.classList.add("hide"), 2600);
      setTimeout(() => { try { el.remove(); } catch {} }, 3200);
    }

    const emojiBar = document.getElementById("emojiBar");
    if (emojiBar) {
      emojiBar.addEventListener("click", (e) => {
        const btn = e.target.closest("[data-emoji]");
        if (!btn) return;
        const em = btn.getAttribute("data-emoji") || "";
        chatText.value = (chatText.value || "") + em;
        chatText.focus();
      });
    }

    chatSend.onclick = () => {
      const name = (chatName.value || "Guest").trim();
      const text = chatText.value.trim();
      if (!text) return;
      socket.emit("chat", { roomId, name, text, role: "guest" });
      chatText.value = "";
    };

    // ===== GUEST AV TOGGLE =====
    const guestMicBtn = document.getElementById("guestMicBtn");
    const guestCamBtn = document.getElementById("guestCamBtn");

    let guestMicOn = true;
    let guestCamOn = true;

    function toggleGuestMic(){
      if (!localStream) return;
      const track = localStream.getAudioTracks()[0];
      if (!track) return;

      guestMicOn = !guestMicOn;
      track.enabled = guestMicOn;
      guestMicBtn.classList.toggle("off", !guestMicOn);
      guestMicBtn.textContent = guestMicOn ? "ğŸ™ï¸" : "ğŸ”‡";
    }

    function toggleGuestCam(){
      if (!localStream) return;
      const track = localStream.getVideoTracks()[0];
      if (!track) return;

      guestCamOn = !guestCamOn;
      track.enabled = guestCamOn;
      guestCamBtn.classList.toggle("off", !guestCamOn);
      guestCamBtn.textContent = guestCamOn ? "ğŸ“·" : "ğŸš«";
    }

    guestMicBtn.onclick = toggleGuestMic;
    guestCamBtn.onclick = toggleGuestCam;

    // Host yÃªu cáº§u guest táº¯t/báº­t mic
    socket.on("guest-set-mic", ({ mute }) => {
      if (!localStream) return;
      const at = localStream.getAudioTracks()[0];
      if (!at) return;

      at.enabled = !mute;

      if (typeof guestMicBtn !== "undefined" && guestMicBtn) {
        guestMicBtn.classList.toggle("off", !!mute);
        guestMicBtn.textContent = mute ? "ğŸ”‡" : "ğŸ™ï¸";
      }
    });

        // Host yÃªu cáº§u guest táº¯t/báº­t camera
socket.on("guest-set-cam", ({ off }) => {
  if (!localStream) return;
  const vt = localStream.getVideoTracks()[0];
  if (!vt) return;

  vt.enabled = !off;

  // Ä‘á»“ng bá»™ icon UI
  if (typeof guestCamBtn !== "undefined" && guestCamBtn) {
    guestCamBtn.classList.toggle("off", !!off);
    guestCamBtn.textContent = off ? "ğŸš«" : "ğŸ“·";
  }
});

    // Host kick guest
    socket.on("guest-kicked", () => {
      alert("Báº¡n Ä‘Ã£ bá»‹ Host kÃ­ch khá»i live.");
      try { leaveLive(); } catch {
        location.href = "/viewer.html?room=" + encodeURIComponent(roomId);
      }
    });

  
    const giftLayer = document.getElementById("giftLayer");

// ===== GIFT ENGINE (client) =====
const GIFT_CLIENT_CATALOG = {
  heart:  { emoji:"â¤ï¸", cost:1,  title:"Tim" },
  flower: { emoji:"ğŸŒ¸", cost:5,  title:"Hoa" },
  rocket: { emoji:"ğŸš€", cost:20, title:"Rocket" },
  coin:   { emoji:"ğŸ’°", cost:50, title:"TÃºi tiá»n" },
  dragon: { emoji:"ğŸ‰", cost:120, title:"Rá»“ng" },
  phoenix:{ emoji:"ğŸ¦…", cost:200, title:"PhÆ°á»£ng hoÃ ng" },
  galaxy: { emoji:"ğŸŒŒ", cost:300, title:"Dáº£i ngÃ¢n hÃ " },
  meteor: { emoji:"â˜„ï¸", cost:500, title:"Sao bÄƒng" },
  king:   { emoji:"ğŸ‘‘", cost:800, title:"VÆ°Æ¡ng miá»‡n" },
  dragonking: { emoji:"ğŸ²", cost:1500, title:"Dragon King" },
  supernova:  { emoji:"ğŸŒ ", cost:2200, title:"Supernova" },
};

document.querySelectorAll(".gift-bar button").forEach(btn=>{
  btn.onclick = ()=>{
    const type = btn.dataset.gift;
    const name = (chatName.value || "Guest").trim().slice(0,20);
    socket.emit("send-gift", { roomId, name, gift: { type, qty: 1 } });
  };
});
// ===== /GIFT ENGINE (client) =====
function spawnGift(type, donor, giftMeta){
  const el = document.createElement("div");
  el.className = "gift-item";

  el.textContent =
    type === "heart"  ? "â¤ï¸" :
    type === "flower" ? "ğŸŒ¸" :
    type === "rocket" ? "ğŸš€" :
    "ğŸ’°";

  el.style.left = Math.random()*80 + 10 + "%";
  el.style.bottom = "10%";

  giftLayer.appendChild(el);
  setTimeout(()=>el.remove(), 2000);
}

socket.on("gift", ({ gift, donor })=>{
  spawnGift(gift.type, donor, gift);
  try{
    const note = document.createElement("div");
    note.className = "gift-toast";
    const em = gift.emoji || (GIFT_CLIENT_CATALOG[gift.type]?.emoji) || "ğŸ";
    note.textContent = `${em} ${donor || "Ai Ä‘Ã³"} táº·ng +${gift.coins || 0} coin`;
    document.body.appendChild(note);
    setTimeout(()=>note.classList.add("hide"), 1600);
    setTimeout(()=>{ try{note.remove();}catch{} }, 2300);
  }catch{}
});

const walletCoinsEl = document.getElementById("walletCoins");
socket.on("wallet-sync", ({ coins }) => { if (walletCoinsEl) walletCoinsEl.textContent = String(coins ?? 0); try{ localStorage.setItem("ls_coins", String(coins ?? 0)); }catch{} });
socket.on("wallet-update", ({ coins }) => { if (walletCoinsEl) walletCoinsEl.textContent = String(coins ?? 0); try{ localStorage.setItem("ls_coins", String(coins ?? 0)); }catch{} });

socket.on("gift-failed", ({ reason, need, coins })=>{
  if (reason === "no_coins"){
    alert(`KhÃ´ng Ä‘á»§ coin! Cáº§n ${need} coin, báº¡n cÃ²n ${coins} coin.`);
  }
});

const giftTotalCoinsEl = document.getElementById("giftTotalCoins");
const giftTopList = document.getElementById("giftTopList");
socket.on("gift-stats", ({ totalCoins, topDonors })=>{
  if (giftTotalCoinsEl) giftTotalCoinsEl.textContent = String(totalCoins ?? 0);
  if (giftTopList){
    const arr = Array.isArray(topDonors) ? topDonors : [];
    giftTopList.innerHTML = arr.length
      ? arr.map((d,i)=>`<div class="gift-board__row"><span>#${i+1} ${d.name}</span><b>${d.coins}</b></div>`).join("")
      : `<div class="gift-board__empty">ChÆ°a cÃ³ donate</div>`;
  }
});
socket.on("host-profile-update", (profile) => {
  document.querySelectorAll(".host-name")
    .forEach(el => el.textContent = profile.name);

  document.querySelectorAll(".host-avatar")
    .forEach(img => img.src = getAvatarByName(profile.name));
});

const chatFab = document.getElementById("chatFab");
const chatInputOverlay = document.getElementById("chatInputOverlay");
const quickChatInput = document.getElementById("quickChatInput");
const quickChatSend = document.getElementById("quickChatSend");

// âœ… iOS/Android: pháº£i focus trong cÃ¹ng â€œuser gestureâ€
function openQuickChat(){
  chatInputOverlay.classList.remove("hidden");
  quickChatInput.focus({ preventScroll: false });
  quickChatInput.click();         // âœ… Ã©p báº­t keyboard (Android)
  quickChatInput.scrollIntoView({ block:"nearest" });
}

function closeQuickChat(){
  chatInputOverlay.classList.add("hidden");
  quickChatInput.blur();
}

chatFab?.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  e.stopPropagation();

  if (chatInputOverlay.classList.contains("hidden")) openQuickChat();
  else closeQuickChat();
});

quickChatSend?.addEventListener("pointerdown", (e)=>{
  e.preventDefault();
  sendQuickChat();
});

quickChatInput?.addEventListener("keydown", (e)=>{
  if (e.key === "Enter") sendQuickChat();
});

function sendQuickChat(){
  const text = (quickChatInput.value || "").trim();
  if (!text) return;

  socket.emit("chat", {
    roomId,
    name: (chatName?.value || "User").trim(),
    text,
    // role tÃ¹y trang báº¡n set:
    // role: "host" / "viewer" / "guest"
  });

  quickChatInput.value = "";
  closeQuickChat();
}


function showKickModal(text){
  const modal = document.getElementById("neonConfirm");
  document.getElementById("ncfTitle").textContent = "Livestream Ä‘Ã£ káº¿t thÃºc";

  modal.classList.remove("hidden");

  let sec = 5;
  const timer = setInterval(() => {
    document.getElementById("ncfTitle").textContent =
      `Host Ä‘Ã£ rá»i phÃ²ng â€¢ vá» Lobby sau ${sec}s`;
    sec--;
    if (sec < 0) {
      clearInterval(timer);
      location.href = "/lobby.html";
    }
  }, 1000);
}

socket.on("room-closed", ({ reason }) => {
  showKickModal("Host Ä‘Ã£ káº¿t thÃºc livestream");
});


  // Cháº·n pinch zoom (iOS)
  document.addEventListener("gesturestart", e => e.preventDefault());
  document.addEventListener("gesturechange", e => e.preventDefault());
  document.addEventListener("gestureend", e => e.preventDefault());

  // Cháº·n Ctrl + scroll zoom (PC)
  document.addEventListener("wheel", e => {
    if (e.ctrlKey) e.preventDefault();
  }, { passive: false });


// ===== ğŸ GIFT PANEL (VIEWER + GUEST) =====
const giftFab   = document.getElementById("giftFab");
const giftPanel = document.getElementById("giftPanel");
const giftClose = document.getElementById("giftClose");
const giftGrid  = document.getElementById("giftGrid");

if (giftFab && giftPanel && giftGrid){
  giftFab.onclick = ()=> giftPanel.classList.toggle("hidden");
  giftClose.onclick = ()=> giftPanel.classList.add("hidden");

  const GIFT_CATALOG = {
    heart:{emoji:"â¤ï¸",cost:1},
    flower:{emoji:"ğŸŒ¸",cost:5},
    rocket:{emoji:"ğŸš€",cost:20},
    coin:{emoji:"ğŸ’°",cost:50},
    dragon:{emoji:"ğŸ‰",cost:120},
    phoenix:{emoji:"ğŸ¦…",cost:200},
    galaxy:{emoji:"ğŸŒŒ",cost:300},
    meteor:{emoji:"â˜„ï¸",cost:500},
    king:{emoji:"ğŸ‘‘",cost:800},
    dragonking:{emoji:"ğŸ²",cost:1500},
    supernova:{emoji:"ğŸŒ ",cost:2200},
  };

  Object.entries(GIFT_CATALOG).forEach(([type,g])=>{
    const el = document.createElement("div");
    el.className = "gift-item";
    el.innerHTML = `
      <div class="gift-emoji">${g.emoji}</div>
      <div class="gift-cost">${g.cost}</div>
    `;
    el.onclick = ()=>{
      socket.emit("send-gift", {
        roomId,
        name: (chatName?.value || "User").trim().slice(0,20),
        gift: { type, qty: 1 }
      });
      giftPanel.classList.add("hidden");
    };
    giftGrid.appendChild(el);
  });
}



  </script>

<!-- VIP TICKER (donation banner) -->
<div id="vipTicker" class="vip-ticker" aria-live="polite"></div>

</body>
</html>
