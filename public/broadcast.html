<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Broadcast</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>ğŸ“± Host</h1>
      <hr />

      <div class="row">
        <div class="card">
          <div class="kv">
            <div class="badge">PhÃ²ng Livestream</div>
            <code id="roomCode">-</code>

            <div class="badge">Link xem</div>
            <code id="viewerLink">-</code>
            <button id="copyViewer">Copy link</button>
            <small>Gá»­i link xem cho khÃ¡ch.</small>

            <hr />
            <button id="btnStart">Báº¯t Ä‘áº§u phÃ¡t sÃ³ng</button>
            <button id="btnStop" disabled>Dá»«ng phÃ¡t sÃ³ng</button>
            <button id="btnFlip" disabled>ğŸ”„ Äáº£o Camera</button>

          </div>
          <hr />
          <div class="log" id="log" style="display: none;"></div>
        </div>

        <div class="card">

       

         <div class="video-card" style="margin-top:10px">
  <div class="live-overlay">
    <span class="dot"></span>
    <b>HOST</b>
    <span style="opacity:.85"></span>
  </div>

<div class="viewer-count" id="viewerCountHost">ğŸ‘: 0</div>

<div class="chat-overlay" id="chatOverlay"></div>

<div class="guest-grid" id="guestGridHost"></div>

  <div class="video-card__inner">
    <video id="preview" autoplay playsinline muted></video>
  </div>

 <div class="av-controls">
  <button id="hostMicBtn" class="av-btn">ğŸ™ï¸</button>
  <button id="hostCamBtn" class="av-btn">ğŸ“·</button>
        </div>

</div>

      </div>
    </div>
  </div>

<hr />
<div class="card">
  <div class="badge badge--info">ğŸ‘¤ KhÃ¡ch xin lÃªn live</div>

<button id="btnMuteGuest" disabled>ğŸ”‡ Táº¯t mic KhÃ¡ch</button>
<button id="btnUnmuteGuest" disabled>ğŸ™ï¸ Báº­t mic KhÃ¡ch</button>
<button id="btnKickGuest" disabled>â›” KÃ­ch KhÃ¡ch</button>

  <div style="margin-top:10px">
    <div class="badge">Link khÃ¡ch má»i</div>
    <code id="guestLink">-</code>
    <button id="copyGuest">Copy link</button>
  </div>

  <hr />
  <div id="guestReq" class="log">ChÆ°a cÃ³ yÃªu cáº§u.</div>
  <div id="pendingList" class="pending-list" style="margin-top:10px"></div>
  <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:10px">
    <button id="btnApproveGuest" disabled style="flex:1">âœ… Cháº¥p nháº­n</button>
    <button id="btnRejectGuest" disabled style="flex:1">âŒ Tá»« chá»‘i</button>
  </div>

  <hr />
  <div class="badge">ğŸ¥ Video khÃ¡ch má»i</div>
  <div class="video-card" style="margin-top:10px">
    <div class="video-card__inner">
      <video id="guestVideo" autoplay playsinline controls></video>
    </div>
  </div>
</div>


<hr />
<div class="card chat">
  <div class="badge badge--info">ğŸ’¬ Chat (Live)</div>

  <div class="chatform">
    <input id="chatName" value="Host" />
    <input id="chatText" placeholder="Nháº­p tin nháº¯n..." />
    <button id="chatSend" class="full">Gá»­i</button>
  </div>

  <div class="emoji-bar" id="emojiBar">
    <button type="button" class="emoji-btn" data-emoji="â¤ï¸">â¤ï¸</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ”¥">ğŸ”¥</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ˜‚">ğŸ˜‚</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ˜®">ğŸ˜®</button>
    <button type="button" class="emoji-btn" data-emoji="ğŸ˜¢">ğŸ˜¢</button>
  </div>


  <div id="chatBox" class="chatbox"></div>
</div>


  
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const logEl = document.getElementById("log");
    const preview = document.getElementById("preview");
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const btnFlip = document.getElementById("btnFlip");

    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || "abc123";
    document.getElementById("roomCode").textContent = roomId;

    const viewerUrl = `${location.origin}/viewer.html?room=${encodeURIComponent(roomId)}`;
    document.getElementById("viewerLink").textContent = viewerUrl;
    document.getElementById("copyViewer").onclick = async () => {
      try { await navigator.clipboard.writeText(viewerUrl); alert("ÄÃ£ copy link xem!"); }
      catch { prompt("Copy thá»§ cÃ´ng:", viewerUrl); }
    };

    // guest link
    const guestUrl = `${location.origin}/guest.html?room=${encodeURIComponent(roomId)}`;
    document.getElementById("guestLink").textContent = guestUrl;
    document.getElementById("copyGuest").onclick = async () => {
      try { await navigator.clipboard.writeText(guestUrl); alert("ÄÃ£ copy link Guest!"); }
      catch { prompt("Copy thá»§ cÃ´ng:", guestUrl); }
    };

    const socket = io();

    let localStream = null;
    let currentFacing = "user"; // user | environment

    // One RTCPeerConnection per viewer
    const pcs = new Map();

    // Guest state (multi-guest)
    const pendingGuests = new Set();
    const approvedGuests = new Set();
    const guestPCsIn = new Map(); // guestId -> RTCPeerConnection
    const guestReq = document.getElementById("guestReq");
    const btnApproveGuest = document.getElementById("btnApproveGuest");
    const btnRejectGuest = document.getElementById("btnRejectGuest");
    const guestVideo = document.getElementById("guestVideo");
    const pendingList = document.getElementById("pendingList");
    const guestGridHost = document.getElementById("guestGridHost");

    function ensureGuestTile(guestId){
      if (!guestGridHost) return null;
      let tile = guestGridHost.querySelector(`[data-guest="${guestId}"]`);
      if (tile) return tile;
      tile = document.createElement("div");
      tile.className = "guest-tile";
      tile.dataset.guest = guestId;
      tile.innerHTML = `
        <div class="guest-tag">GUEST</div>
        <video autoplay playsinline></video>
        <div class="guest-actions">
          <button type="button" data-act="mute" title="Táº¯t mic">ğŸ”‡</button>
          <button type="button" data-act="unmute" title="Báº­t mic">ğŸ™ï¸</button>
          <button type="button" data-act="kick" title="KÃ­ch">â›”</button>
        </div>
      `;
      guestGridHost.appendChild(tile);

      // action buttons
      tile.addEventListener("click", (e)=>{
        const btn = e.target.closest("button[data-act]");
        if (!btn) return;
        const act = btn.getAttribute("data-act");
        if (act === "mute") socket.emit("host-mute-guest", { roomId, guestId, mute: true });
        if (act === "unmute") socket.emit("host-mute-guest", { roomId, guestId, mute: false });
        if (act === "kick") socket.emit("host-kick-guest", { roomId, guestId });
      });
      return tile;
    }

    function removeGuestTile(guestId){
      if (!guestGridHost) return;
      const tile = guestGridHost.querySelector(`[data-guest="${guestId}"]`);
      if (tile) tile.remove();
    }

    function renderPending(){
      if (!pendingList) return;
      pendingList.innerHTML = "";
      const arr = Array.from(pendingGuests);
      if (!arr.length) return;
      for (const gid of arr) {
        const row = document.createElement("div");
        row.className = "pending-row";
        row.innerHTML = `
          <div class="pending-id">${gid}</div>
          <div class="pending-actions">
            <button type="button" data-act="approve">âœ… Duyá»‡t</button>
            <button type="button" data-act="reject">âŒ Tá»« chá»‘i</button>
          </div>
        `;
        row.addEventListener("click", (e)=>{
          const b = e.target.closest("button[data-act]");
          if (!b) return;
          const act = b.getAttribute("data-act");
          if (act === "approve") {
            socket.emit("guest-approve", { roomId, guestId: gid });
            pendingGuests.delete(gid);
            approvedGuests.add(gid);
            renderPending();
            // host also requests to watch this guest
            socket.emit("watch-guest", { roomId, guestId: gid });
          }
          if (act === "reject") {
            socket.emit("guest-reject", { roomId, guestId: gid });
            pendingGuests.delete(gid);
            renderPending();
          }
        });
        pendingList.appendChild(row);
      }
    }

    async function getRtcConfig() {
      const fallback = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

      try {
        const r = await fetch("/ice", { cache: "no-store" });
        if (!r.ok) return fallback;

        const data = await r.json();
        if (!data.iceServers || !Array.isArray(data.iceServers)) return fallback;

        const cleanedIceServers = data.iceServers
          .map(server => {
            let urls = server.urls;
            if (!urls) return null;
            if (!Array.isArray(urls)) urls = [urls];

            // remove invalid STUN urls that contain ?transport=
            const safeUrls = urls.filter(u =>
              typeof u === "string" &&
              !(u.startsWith("stun:") && u.includes("?transport="))
            );
            if (safeUrls.length === 0) return null;
            return { ...server, urls: safeUrls };
          })
          .filter(Boolean);

        if (cleanedIceServers.length === 0) return fallback;
        return { iceServers: cleanedIceServers };
      } catch (e) {
        console.error("ICE fetch error:", e);
        return fallback;
      }
    }

    function log(msg) {
      logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

    socket.emit("join-room", { roomId, role: "broadcaster" });

    // ===== Viewer -> Host streaming =====
    socket.on("watcher", async ({ viewerId }) => {
      if (!localStream) {
        log("CÃ³ viewer nhÆ°ng báº¡n chÆ°a Start camera.");
        return;
      }
      if (pcs.has(viewerId)) return;

      log(`Viewer join: ${viewerId}`);

      const rtcConfig = await getRtcConfig();
      const pc = new RTCPeerConnection(rtcConfig);
      pcs.set(viewerId, pc);

      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      pc.onicecandidate = (e) => {
        if (e.candidate) socket.emit("candidate", { to: viewerId, candidate: e.candidate });
      };

      pc.oniceconnectionstatechange = () => log(`ICE(${viewerId}): ${pc.iceConnectionState}`);

      try {
        const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
        await pc.setLocalDescription(offer);
        socket.emit("offer", { to: viewerId, description: pc.localDescription });
      } catch (err) {
        log("Lá»—i táº¡o offer: " + err.message);
      }
    });

    socket.on("answer", async ({ from, description }) => {
      // could be viewer answer OR guest answer (rare in this flow)
      const pc = pcs.get(from);
      if (pc) {
        try {
          await pc.setRemoteDescription(description);
          log(`Nháº­n answer tá»«: ${from}`);
        } catch (err) {
          log("Lá»—i setRemoteDescription(answer): " + err.message);
        }
        return;
      }
      const pcg = guestPCsIn.get(from);
      if (pcg) {
        try {
          await pcg.setRemoteDescription(description);
          log("Nháº­n answer tá»« guest: " + from);
        } catch (err) {
          log("Lá»—i answer guest: " + err.message);
        }
      
      }
    });

    socket.on("candidate", async ({ from, candidate }) => {
      const pc = pcs.get(from);
      if (pc) {
        try { await pc.addIceCandidate(candidate); }
        catch (err) { log("Lá»—i addIceCandidate(viewer): " + err.message); }
        return;
      }
      const pcg = guestPCsIn.get(from);
      if (pcg) {
        try {
          await pcg.setRemoteDescription(description);
          log("Nháº­n answer tá»« guest: " + from);
        } catch (err) {
          log("Lá»—i answer guest: " + err.message);
        }
      }
        
    });

    socket.on("disconnectPeer", ({ peerId }) => {
      const pc = pcs.get(peerId);
      if (pc) {
        pc.close();
        pcs.delete(peerId);
        log(`Viewer rá»i: ${peerId} -> close peer`);
      }
    });

    // ===== Guest request/approve =====
    socket.on("guest-request", ({ guestId }) => {
      pendingGuests.add(guestId);
      guestReq.textContent = `CÃ³ khÃ¡ch xin lÃªn live (${pendingGuests.size})`;
      btnApproveGuest.disabled = true;
      btnRejectGuest.disabled = true;
      renderPending();
      log("CÃ³ guest xin lÃªn live: " + guestId);
    });

    socket.on("guest-offline", ({ guestId }) => {
      log("Guest offline: " + (guestId || ""));
      if (guestId) {
        approvedGuests.delete(guestId);
        pendingGuests.delete(guestId);
        const pc = guestPCsIn.get(guestId);
        if (pc) { try { pc.close(); } catch {} guestPCsIn.delete(guestId); }
        removeGuestTile(guestId);
      }
      guestReq.textContent = "Guest Ä‘Ã£ rá»i.";
      renderPending();
      // backward: clear big guestVideo if used
      if (guestVideo) guestVideo.srcObject = null;
    });

    btnApproveGuest.onclick = () => {};
    btnRejectGuest.onclick = () => {};

    // Host receives OFFER from guest (guest creates offer to everyone who "watch-guest")
    socket.on("offer", async ({ from, description }) => {
      // Only handle guest offers here (viewers never send offers to host in this app)
      // Multi-guest: keep one PC per guest
      if (guestPCsIn.has(from)) {
        try { guestPCsIn.get(from).close(); } catch {}
        guestPCsIn.delete(from);
      }

      const rtcConfig = await getRtcConfig();
      const pc = new RTCPeerConnection(rtcConfig);
      guestPCsIn.set(from, pc);

      // send host tracks back to guest so guest can hear/see host (co-talk)
      if (localStream) {
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      }

      pc.ontrack = (e) => {
        // attach to tile video
        const tile = ensureGuestTile(from);
        const v = tile ? tile.querySelector("video") : null;
        if (v) {
          v.srcObject = e.streams[0];
          v.play().catch(() => {});
        } else if (guestVideo) {
          // fallback to big guestVideo
          guestVideo.srcObject = e.streams[0];
        }
      };

      pc.onicecandidate = (e) => {
        if (e.candidate) socket.emit("candidate", { to: from, candidate: e.candidate });
      };

      pc.oniceconnectionstatechange = () => log(`ICE(GUEST ${from}): ${pc.iceConnectionState}`);

      try {
        await pc.setRemoteDescription(description);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("answer", { to: from, description: pc.localDescription });
        log("ÄÃ£ tráº£ lá»i offer cá»§a guest: " + from);
      } catch (err) {
        log("Lá»—i xá»­ lÃ½ offer guest: " + err.message);
      }
    });

    // ===== Start/Stop/Flip =====
    async function start() {
      if (localStream) return;

      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { ideal: currentFacing } },
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        });

        preview.srcObject = localStream;
        btnStart.disabled = true;
        btnStop.disabled = false;
        btnFlip.disabled = false;

        log("ÄÃ£ Start camera + mic. Gá»­i link xem cho ngÆ°á»i khÃ¡c.");
        socket.emit("broadcaster-ready", { roomId });
      } catch (err) {
        log("KhÃ´ng má»Ÿ Ä‘Æ°á»£c camera/mic: " + err.message);
        alert("KhÃ´ng má»Ÿ Ä‘Æ°á»£c camera/mic. Náº¿u trÃªn Ä‘iá»‡n thoáº¡i: cáº§n HTTPS.");
      }
    }

    function stop() {
      // close all viewer peers
      for (const [id, pc] of pcs.entries()) {
        try { pc.close(); } catch {}
        pcs.delete(id);
      }

      // close guest peers
      for (const pc of guestPCsIn.values()) { try { pc.close(); } catch {} }
      guestPCsIn.clear();
      guestVideo.srcObject = null;
      if (guestGridHost) guestGridHost.innerHTML = "";

      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      preview.srcObject = null;

      btnStart.disabled = false;
      btnStop.disabled = true;
      btnFlip.disabled = true;

      log("ÄÃ£ Stop.");
    }

    async function flipCamera() {
      if (!localStream) return;

      currentFacing = (currentFacing === "user") ? "environment" : "user";
      log("Äang Ä‘á»•i camera sang: " + (currentFacing === "user" ? "CAM TRÆ¯á»šC" : "CAM SAU"));

      try {
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { ideal: currentFacing } },
          audio: false
        });

        const newVideoTrack = newStream.getVideoTracks()[0];
        if (!newVideoTrack) throw new Error("KhÃ´ng láº¥y Ä‘Æ°á»£c video track má»›i");

        const oldVideoTrack = localStream.getVideoTracks()[0];
        if (oldVideoTrack) {
          localStream.removeTrack(oldVideoTrack);
          oldVideoTrack.stop();
        }
        localStream.addTrack(newVideoTrack);
        preview.srcObject = localStream;

        // replace for all viewer peers
        for (const [viewerId, pc] of pcs.entries()) {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender) await sender.replaceTrack(newVideoTrack);
        }

        // replace for all guest peers
        for (const pc of guestPCsIn.values()) {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender) await sender.replaceTrack(newVideoTrack);
        }

        log("âœ… Äá»•i camera thÃ nh cÃ´ng.");
      } catch (err) {
        log("âŒ Äá»•i camera tháº¥t báº¡i: " + err.message);
        currentFacing = (currentFacing === "user") ? "environment" : "user";
        alert("KhÃ´ng Ä‘á»•i Ä‘Æ°á»£c camera. HÃ£y kiá»ƒm tra quyá»n camera.");
      }
    }

    btnStart.onclick = start;
    btnStop.onclick = stop;
    btnFlip.onclick = flipCamera;

    window.addEventListener("beforeunload", stop);

    // ===== CHAT (BROADCAST) =====
    const chatBox = document.getElementById("chatBox");
    const chatName = document.getElementById("chatName");
    const chatText = document.getElementById("chatText");
    const chatSend = document.getElementById("chatSend");

    function addChat(msg) {
      const time = new Date(msg.ts).toLocaleTimeString();
      const line = document.createElement("div");
      line.textContent = `[${time}] ${msg.name}: ${msg.text}`;
      chatBox.appendChild(line);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    socket.on("chat", (msg)=>{ addChat(msg); pushOverlay(msg); });

    // ===== CHAT OVERLAY + EMOJI QUICK BAR ===== // CHAT OVERLAY
    const chatOverlay = document.getElementById("chatOverlay");
    function pushOverlay(msg){
      if (!chatOverlay) return;
      const el = document.createElement("div");
      el.className = "chat-bubble";
      el.textContent = `${msg.name}: ${msg.text}`;
      chatOverlay.appendChild(el);

      // keep only last 4 bubbles
      while (chatOverlay.children.length > 4) chatOverlay.removeChild(chatOverlay.firstChild);

      // auto fade + remove
      setTimeout(() => el.classList.add("hide"), 2600);
      setTimeout(() => { try { el.remove(); } catch {} }, 3200);
    }

    // add emoji buttons
    const emojiBar = document.getElementById("emojiBar");
    if (emojiBar) {
      emojiBar.addEventListener("click", (e) => {
        const btn = e.target.closest("[data-emoji]");
        if (!btn) return;
        const em = btn.getAttribute("data-emoji") || "";
        chatText.value = (chatText.value || "") + em;
        chatText.focus();
      });
    }


    chatSend.onclick = () => {
      const name = (chatName.value || "Host").trim();
      const text = chatText.value.trim();
      if (!text) return;

      socket.emit("chat", { roomId, name, text });
      chatText.value = "";
    };

// ===== HOST AV TOGGLE =====
const hostMicBtn = document.getElementById("hostMicBtn");
const hostCamBtn = document.getElementById("hostCamBtn");

let hostMicOn = true;
let hostCamOn = true;

function toggleHostMic(){
  if (!localStream) return;
  const track = localStream.getAudioTracks()[0];
  if (!track) return;

  hostMicOn = !hostMicOn;
  track.enabled = hostMicOn;
  hostMicBtn.classList.toggle("off", !hostMicOn);
  hostMicBtn.textContent = hostMicOn ? "ğŸ™ï¸" : "ğŸ”‡";
}

function toggleHostCam(){
  if (!localStream) return;
  const track = localStream.getVideoTracks()[0];
  if (!track) return;

  hostCamOn = !hostCamOn;
  track.enabled = hostCamOn;
  hostCamBtn.classList.toggle("off", !hostCamOn);
  hostCamBtn.textContent = hostCamOn ? "ğŸ“·" : "ğŸš«";
}

hostMicBtn.onclick = toggleHostMic;
hostCamBtn.onclick = toggleHostCam;

    
const btnMuteGuest = document.getElementById("btnMuteGuest");
const btnUnmuteGuest = document.getElementById("btnUnmuteGuest");
const btnKickGuest = document.getElementById("btnKickGuest");

function setGuestControls(on) {
  btnMuteGuest.disabled = !on;
  btnUnmuteGuest.disabled = !on;
  btnKickGuest.disabled = !on;
}

// khi host cháº¥p nháº­n guest xong (hoáº·c khi guest-online), báº­t controls
socket.on("guest-online", ({ guestId }) => {
  setGuestControls(true);
  if (guestId) {
    approvedGuests.add(guestId);
    ensureGuestTile(guestId);
    // if host wants to watch immediately
    socket.emit("watch-guest", { roomId, guestId });
  }
});

socket.on("guest-list", ({ guests }) => {
  // sync full list
  const list = Array.isArray(guests) ? guests : [];
  // remove missing
  if (guestGridHost) {
    for (const el of Array.from(guestGridHost.querySelectorAll("[data-guest]"))) {
      const gid = el.getAttribute("data-guest");
      if (gid && !list.includes(gid)) removeGuestTile(gid);
    }
  }
  for (const gid of list) {
    approvedGuests.add(gid);
    ensureGuestTile(gid);
    socket.emit("watch-guest", { roomId, guestId: gid });
  }
});

// khi guest-offline thÃ¬ táº¯t controls
socket.on("guest-offline", ({ guestId }) => {
  if (guestId) {
    // tile removed in other handler above
  }
  // if no guests left, disable global buttons
  setGuestControls(approvedGuests.size > 0);
});

// nÃºt Ä‘iá»u khiá»ƒn
function pickAnyGuest(){
  const arr = Array.from(approvedGuests);
  return arr[0] || null;
}
btnMuteGuest.onclick = () => {
  const gid = pickAnyGuest();
  if (!gid) return;
  socket.emit("host-mute-guest", { roomId, guestId: gid, mute: true });
};
btnUnmuteGuest.onclick = () => {
  const gid = pickAnyGuest();
  if (!gid) return;
  socket.emit("host-mute-guest", { roomId, guestId: gid, mute: false });
};
btnKickGuest.onclick = () => {
  const gid = pickAnyGuest();
  if (!gid) return;
  socket.emit("host-kick-guest", { roomId, guestId: gid });
};


const viewerCountHost = document.getElementById("viewerCountHost");

socket.on("viewer-count", ({ count }) => {
  if (viewerCountHost) {
    viewerCountHost.textContent = `ğŸ‘: ${count}`;
  }
});

  </script>
</body>
</html>
