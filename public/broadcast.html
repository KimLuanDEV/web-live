<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Broadcast</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>ğŸ“± Broadcast (NgÆ°á»i phÃ¡t)</h1>
      <small>Má»Ÿ trÃªn Ä‘iá»‡n thoáº¡i vÃ  báº¥m Start Ä‘á»ƒ phÃ¡t live.</small>
      <hr />

      <div class="row">
        <div class="card">
          <div class="kv">
            <div class="badge">PhÃ²ng</div>
            <code id="roomCode">-</code>

            <div class="badge">Link xem</div>
            <code id="viewerLink">-</code>
            <button id="copyViewer">Copy link xem</button>

            <hr />
            <button id="btnStart">Start Camera + Mic</button>
            <button id="btnStop" disabled>Stop</button>
          </div>
          <hr />
          <div class="log" id="log"></div>
        </div>

        <div class="card">
          <div class="badge">Preview</div>
          <div class="video-wrap" style="margin-top:10px">
            <!-- muted Ä‘á»ƒ preview tá»± cháº¡y trÃªn mobile -->
            <video id="preview" autoplay playsinline muted></video>
            <div class="av-controls">
              <button id="hostFlipBtn" class="av-btn" title="Äáº£o camera">ğŸ”„</button>
            </div>

          </div>
          <small>Preview luÃ´n muted Ä‘á»ƒ trÃ¡nh bá»‹ cháº·n autoplay.</small>
        </div>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js">
    // ===== HOST: FLIP CAMERA (overlay button) =====
    const hostFlipBtn = document.getElementById("hostFlipBtn");
    let hostFacing = "user"; // "user" | "environment"

    async function flipHostCamera() {
      if (!localStream) return;

      hostFacing = (hostFacing === "user") ? "environment" : "user";
      log("ğŸ”„ Äáº£o camera Host: " + (hostFacing === "user" ? "TRÆ¯á»šC" : "SAU"));

      try {
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: hostFacing }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });

        const newVideoTrack = newStream.getVideoTracks()[0];
        if (!newVideoTrack) throw new Error("KhÃ´ng láº¥y Ä‘Æ°á»£c video track má»›i");

        const oldVideoTrack = localStream.getVideoTracks()[0];
        if (oldVideoTrack) {
          localStream.removeTrack(oldVideoTrack);
          oldVideoTrack.stop();
        }
        localStream.addTrack(newVideoTrack);

        // update preview
        preview.srcObject = localStream;

        // replaceTrack for all viewers
        for (const [viewerId, pc] of pcs.entries()) {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender) await sender.replaceTrack(newVideoTrack);
          else pc.addTrack(newVideoTrack, localStream);
        }

        log("âœ… ÄÃ£ Ä‘áº£o camera Host.");
      } catch (err) {
        // revert facing toggle on error
        hostFacing = (hostFacing === "user") ? "environment" : "user";
        log("âŒ Äáº£o camera lá»—i: " + err.message);
        alert("KhÃ´ng Ä‘áº£o Ä‘Æ°á»£c camera: " + err.message);
      }
    }

    if (hostFlipBtn) {
      hostFlipBtn.onclick = flipHostCamera;
    }

</script>
  <script>
    const logEl = document.getElementById("log");
    const preview = document.getElementById("preview");
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");

    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || "abc123";

    document.getElementById("roomCode").textContent = roomId;

    const viewerUrl = `${location.origin}/viewer.html?room=${encodeURIComponent(roomId)}`;
    document.getElementById("viewerLink").textContent = viewerUrl;
    document.getElementById("copyViewer").onclick = async () => {
      try { await navigator.clipboard.writeText(viewerUrl); alert("ÄÃ£ copy link xem!"); }
      catch { prompt("Copy thá»§ cÃ´ng:", viewerUrl); }
    };

    const socket = io();
    let localStream = null;

    // One RTCPeerConnection per viewer
    const pcs = new Map();

    // STUN server (demo). TURN sáº½ cáº§n náº¿u máº¡ng khÃ³ (4G/Carrier NAT)
async function getRtcConfig() {
  // fallback STUN náº¿u Twilio lá»—i
  const fallback = {
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  };

  try {
    const r = await fetch("/ice", { cache: "no-store" });
    if (!r.ok) return fallback;
    const data = await r.json();
    if (!data.iceServers || !Array.isArray(data.iceServers)) return fallback;
    return { iceServers: data.iceServers };
  } catch {
    return fallback;
  }
}



    function log(msg) {
      logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

    socket.emit("join-room", { roomId, role: "broadcaster" });

    socket.on("watcher", async ({ viewerId }) => {
      if (!localStream) {
        log("CÃ³ viewer nhÆ°ng báº¡n chÆ°a Start camera.");
        return;
      }
      log(`Viewer join: ${viewerId}`);

      const rtcConfig = await getRtcConfig();
const pc = new RTCPeerConnection(rtcConfig);



      pcs.set(viewerId, pc);

      // Add tracks
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          socket.emit("candidate", { to: viewerId, candidate: e.candidate });
        }
      };

      pc.oniceconnectionstatechange = () => {
        log(`ICE(${viewerId}): ${pc.iceConnectionState}`);
      };

      try {
        const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
        await pc.setLocalDescription(offer);
        socket.emit("offer", { to: viewerId, description: pc.localDescription });
      } catch (err) {
        log("Lá»—i táº¡o offer: " + err.message);
      }
    });

    socket.on("answer", async ({ from, description }) => {
      const pc = pcs.get(from);
      if (!pc) return;
      try {
        await pc.setRemoteDescription(description);
        log(`Nháº­n answer tá»« viewer: ${from}`);
      } catch (err) {
        log("Lá»—i setRemoteDescription(answer): " + err.message);
      }
    });

    socket.on("candidate", async ({ from, candidate }) => {
      const pc = pcs.get(from);
      if (!pc) return;
      try {
        await pc.addIceCandidate(candidate);
      } catch (err) {
        log("Lá»—i addIceCandidate: " + err.message);
      }
    });

    socket.on("disconnectPeer", ({ peerId }) => {
      const pc = pcs.get(peerId);
      if (pc) {
        pc.close();
        pcs.delete(peerId);
        log(`Viewer rá»i: ${peerId} -> close peer`);
      }
    });

    socket.on("broadcaster-changed", () => {
      log("CÃ³ broadcaster má»›i trong phÃ²ng (Ä‘ang lÃ  báº¡n).");
    });

    async function start() {
      if (localStream) return;

      // Mobile best practice: request via user gesture (button click)
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: "user" },
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        });

        preview.srcObject = localStream;
        btnStart.disabled = true;
        btnStop.disabled = false;

        log("ÄÃ£ Start camera + mic. Gá»­i link xem cho ngÆ°á»i khÃ¡c.");

        // Náº¿u viewers Ä‘Ã£ vÃ o trÆ°á»›c, server sáº½ gá»­i danh sÃ¡ch
        // MÃ¬nh sáº½ yÃªu cáº§u há» reload báº±ng broadcaster-online Ä‘Ã£ Ä‘á»§.
      } catch (err) {
        log("KhÃ´ng má»Ÿ Ä‘Æ°á»£c camera/mic: " + err.message);
        alert("KhÃ´ng má»Ÿ Ä‘Æ°á»£c camera/mic. Náº¿u trÃªn Ä‘iá»‡n thoáº¡i: cáº§n HTTPS.");
      }
    }

    function stop() {
      if (!localStream) return;

      // close all peers
      for (const [id, pc] of pcs.entries()) {
        pc.close();
        pcs.delete(id);
      }

      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
      preview.srcObject = null;

      btnStart.disabled = false;
      btnStop.disabled = true;

      log("ÄÃ£ Stop.");
    }

    btnStart.onclick = start;
    btnStop.onclick = stop;

    // cleanup on close
    window.addEventListener("beforeunload", stop);
  
  
    async function flipHostCamera() {
      if (!localStream) return;

      hostFacing = (hostFacing === "user") ? "environment" : "user";
      log("ğŸ”„ Äáº£o camera Host: " + (hostFacing === "user" ? "TRÆ¯á»šC" : "SAU"));

      try {
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: hostFacing }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });

        const newVideoTrack = newStream.getVideoTracks()[0];
        if (!newVideoTrack) throw new Error("KhÃ´ng láº¥y Ä‘Æ°á»£c video track má»›i");

        const oldVideoTrack = localStream.getVideoTracks()[0];
        if (oldVideoTrack) {
          localStream.removeTrack(oldVideoTrack);
          oldVideoTrack.stop();
        }
        localStream.addTrack(newVideoTrack);

        // update preview
        preview.srcObject = localStream;

        // replaceTrack for all viewers
        for (const [viewerId, pc] of pcs.entries()) {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender) await sender.replaceTrack(newVideoTrack);
          else pc.addTrack(newVideoTrack, localStream);
        }

        log("âœ… ÄÃ£ Ä‘áº£o camera Host.");
      } catch (err) {
        // revert facing toggle on error
        hostFacing = (hostFacing === "user") ? "environment" : "user";
        log("âŒ Äáº£o camera lá»—i: " + err.message);
        alert("KhÃ´ng Ä‘áº£o Ä‘Æ°á»£c camera: " + err.message);
      }
    }

    if (hostFlipBtn) {
      hostFlipBtn.onclick = flipHostCamera;
    }

</script>
</body>
</html>
