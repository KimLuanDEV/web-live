<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
 <meta
  name="viewport"
  content="width=device-width,
           initial-scale=1,
           maximum-scale=1,
           minimum-scale=1,
           user-scalable=no"
/>

  <title>Host - Livestream Pro</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
<script src="/guard.js"></script>

  <div class="container">
    <div class="card">

      <div class="page-header">
  <h1 class="page-title">ğŸ“± Host</h1>

  <span class="status-badge status-live" id="statusBadge">
    ğŸ”´ LIVE
  </span>

  <button id="btnBackLobby" class="page-exit-btn" title="Quay vá» Lobby">
    ğŸšª
  </button>
</div>



      <div class="card" style="display: none;">
  <div class="badge badge--info">ğŸ‘¤ Cáº­p nháº­t tÃªn hiá»ƒn thá»‹ ngoÃ i Lobby</div>
  <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">
    <img id="hostAvatarPreview"
         src="https://static.vecteezy.com/system/resources/previews/011/016/931/original/live-streaming-icon-for-the-broadcast-system-live-streaming-icon-design-with-red-and-white-colors-live-streaming-image-with-text-effect-red-and-white-gradient-colors-free-png.png"
         style="width:56px;height:56px;border-radius:50%;object-fit:cover;border:1px solid #fff3">
    
    <div style="flex:1">
      <input id="hostNameInput" placeholder="TÃªn host..." />
      
    </div>
    <button id="btnUpdateProfile">ğŸ’¾ LÆ°u</button>
  </div>
</div>



      <hr />
      <div class="row">

        <div class="card" style="display: none;">
          <div class="kv">
            <div class="badge">PhÃ²ng Livestream</div>
            <code id="roomCode" >-</code>

          </div>
          <hr />
          <div class="log" id="log" style="display: none;"></div>
        </div>


        
     <div class="live-stage" id="liveStageHost" style="margin-top:10px">

      <div class="gift-layer" id="giftLayer"></div>

  <!-- HOST MAIN -->
  <div class="video-card live-main" id="hostCard">
    <div class="live-overlay">
      <span class="dot"></span>
      <b>HOST</b>
      <span class="live-meta">
        <span class="meta-item" id="viewerCountHost">ğŸ‘ 0</span>
        <span class="meta-sep">â€¢</span>
        <span class="meta-item" id="liveTimerHost">â± 00:00:00</span>
      </span>
    </div>

<div class="chat-overlay" id="chatOverlay"></div>




<!-- CHAT QUICK BUTTON -->
<button class="chat-fab" id="chatFab">ğŸ’¬</button>

<!-- GUEST REQUEST ICON -->
<button
  id="guestReqIcon"
  class="guest-req-icon"
  title="KhÃ¡ch xin lÃªn live"
>
  ğŸ‘¤
  <span class="guest-req-dot" id="guestReqDot"></span>
</button>

<!-- CHAT INPUT OVERLAY -->
<div class="chat-input-overlay hidden" id="chatInputOverlay">
  <input
    id="quickChatInput"
    placeholder="Nháº­p tin nháº¯n..."
    autocomplete="off"
  />
  <button id="quickChatSend">â¤</button>
</div>

<div class="pin-overlay" id="pinOverlay"></div>

        <div class="reactions-layer" id="reactionsLayerHost"></div>
        <div class="ctrl-tab" id="ctrlTabHost">
          <button class="ctrl-fab" id="ctrlFabHost" type="button" aria-expanded="false" title="Má»Ÿ Ä‘iá»u khiá»ƒn">â˜°</button>
          <div class="ctrl-drawer" id="ctrlDrawerHost" hidden>
            <div class="ctrl-title">ğŸ› Äiá»u khiá»ƒn</div>
            <div class="ctrl-grid">
              <!-- LIVE -->
              <button id="btnStart" class="av-btn" title="Báº¯t Ä‘áº§u phÃ¡t sÃ³ng">â–¶ï¸</button>
              <button id="btnStop" class="av-btn" title="Dá»«ng phÃ¡t sÃ³ng" disabled>â¹ï¸</button>

              <!-- HOST AV -->
              <button id="hostMicBtn" class="av-btn" title="Báº­t / Táº¯t mic">ğŸ™ï¸</button>
              <button id="hostCamBtn" class="av-btn" title="Báº­t / Táº¯t camera">ğŸ“·</button>
              <button id="hostFlipBtn" class="av-btn" title="Äáº£o camera" disabled>ğŸ”„</button>

              <!-- LINKS -->
              <button id="copyViewer" class="av-btn" title="Copy link xem">ğŸ‘€</button>
              <button id="copyGuest" class="av-btn" title="Copy link khÃ¡ch má»i">ğŸ‘¤</button>

              <!-- GUEST CONTROL -->
              <button id="btnMuteGuest" class="av-btn" title="Táº¯t mic khÃ¡ch" disabled>ğŸ”‡</button>
              <button id="btnUnmuteGuest" class="av-btn" title="Báº­t mic khÃ¡ch" disabled>ğŸ™ï¸</button>
              <button id="btnOffCamGuest" class="av-btn" title="Táº¯t camera khÃ¡ch" disabled>ğŸš«</button>
              <button id="btnOnCamGuest"  class="av-btn" title="Báº­t camera khÃ¡ch" disabled>ğŸ“·</button>
              <button id="btnKickGuest" class="av-btn off" title="KÃ­ch khÃ¡ch" disabled>â›”</button>

               <!-- HÆ°á»›ng dáº«n -->
              <button id="btnHostGuide" class="av-btn" title="HÆ°á»›ng dáº«n sá»­ dá»¥ng">â”</button>

               <!-- Ghim -->
              <button id="btnPinToggle"class="av-btn"title="Ghim ná»™i dung lÃªn video">ğŸ“Œ</button>




            </div>
            <div class="ctrl-hint">Nháº¥n â˜° Ä‘á»ƒ thu gá»n</div>
          </div>
        </div>

<div class="video-card__inner">
      <video id="preview" autoplay playsinline muted></video>
    </div>
  

    <div class="join-overlay" id="joinOverlayHost" aria-live="polite"></div>
    

  </div>

 
  <!-- GUEST PIP -->
  <div class="pip-wrap" id="guestPipWrapHost" aria-hidden="true">
    <div class="pip-badge">ğŸ‘¤ GUEST</div>
    <video id="guestVideo" autoplay playsinline controls></video>
  </div>
</div>

  

    


    </div>
  </div>





<hr />
<div class="card chat">
  <div class="badge badge--info" style="display: none;">ğŸ’¬ Chat (Live)</div>

  <div class="chatform" style="display: none;">
    <input id="chatName" value="Host" />
    <input id="chatText" placeholder="Nháº­p tin nháº¯n..." />
    <button id="chatSend" class="full">Gá»­i</button>
  </div>

  
   <div class="emoji-bar" id="emojiBar" style="display: none;">
      <button type="button" class="emoji-btn" data-emoji="â¤ï¸">â¤ï¸</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ”¥">ğŸ”¥</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ˜‚">ğŸ˜‚</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ‘">ğŸ‘</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ˜®">ğŸ˜®</button>
      <button type="button" class="emoji-btn" data-emoji="ğŸ˜¢">ğŸ˜¢</button>
    </div>


  <div id="chatBox" class="chatbox"></div>

</div>

<div class="card" style="margin-top:12px">
  <div class="badge badge--info">ğŸ Gift Engine</div>
  <div class="gift-board gift-board--host">
    <div class="gift-board__meta">Tá»•ng donate: <b id="giftTotalCoinsHost">0</b> coin</div>
    <div id="giftTopListHost" class="gift-board__list"></div>
  </div>
</div>


<!-- NEON CONFIRM (Back to Lobby) -->
<div id="neonConfirm" class="ncf hidden" aria-hidden="true">
  <div class="ncf__bg"></div>

  <div class="ncf__box" role="dialog" aria-modal="true" aria-labelledby="ncfTitle">
    <div class="ncf__frame"></div>
    <div class="ncf__scan"></div>

    <div class="ncf__top">
      <div class="ncf__pill">
        <span class="ncf__dot"></span>
        <span>Rá»œI PHÃ’NG LIVE</span>
      </div>
      <button class="ncf__x" id="ncfX" type="button" aria-label="ÄÃ³ng">âœ•</button>
    </div>

    <h3 id="ncfTitle" class="ncf__title">Quay vá» Lobby?</h3>

    <div class="ncf__desc">
      <div class="ncf__row">â€¢ Livestream sáº½ bá»‹ dá»«ng</div>
      <div class="ncf__row">â€¢ NgÆ°á»i xem sáº½ bá»‹ ngáº¯t káº¿t ná»‘i</div>
      <div class="ncf__row">â€¢ Báº¡n cÃ³ thá»ƒ táº¡o phÃ²ng láº¡i sau</div>
    </div>

    <div class="ncf__actions">
      <button id="ncfCancel" class="ncf__btn ncf__btn--ghost" type="button">á» láº¡i</button>
      <button id="ncfOk" class="ncf__btn ncf__btn--main" type="button">âœ… Rá»i & vá» Lobby</button>
    </div>
  </div>
</div>



<!-- HOST GUIDE MODAL (NEON) -->
<div id="hostGuideModal" class="hgm hidden" aria-hidden="true">
  <div class="hgm__bg"></div>

  <div class="hgm__box" role="dialog" aria-modal="true" aria-labelledby="hgmTitle">
    <div class="hgm__frame"></div>
    <div class="hgm__scan"></div>

    <div class="hgm__top">
      <div class="hgm__pill">
        <span class="hgm__dot"></span>
        <span>HÆ¯á»šNG DáºªN HOST</span>
      </div>
      <button class="hgm__x" id="hgmX" type="button" aria-label="ÄÃ³ng">âœ•</button>
    </div>

    <div class="hgm__hero">
      <div class="hgm__kicker">ğŸ¥ HOST PANEL</div>
      <h3 id="hgmTitle" class="hgm__title">CÃ¡ch phÃ¡t sÃ³ng & Ä‘iá»u khiá»ƒn</h3>
      <div class="hgm__sub">
        Báº¡n Ä‘ang á»Ÿ phÃ²ng: <b id="hgmRoom">-</b> â€¢ Nháº¥n â˜° Ä‘á»ƒ má»Ÿ báº£ng Ä‘iá»u khiá»ƒn.
      </div>
    </div>

    <div class="hgm__grid">
      <div class="hgm__card">
        <div class="hgm__ic">â–¶ï¸</div>
        <div>
          <div class="hgm__cardTitle">Báº¯t Ä‘áº§u live</div>
          <div class="hgm__cardText">Báº¥m â–¶ï¸ Ä‘á»ƒ phÃ¡t â€¢ â¹ï¸ Ä‘á»ƒ dá»«ng.</div>
        </div>
      </div>

      <div class="hgm__card">
        <div class="hgm__ic">ğŸ™ï¸</div>
        <div>
          <div class="hgm__cardTitle">Mic / Camera</div>
          <div class="hgm__cardText">DÃ¹ng ğŸ™ï¸ / ğŸ“· Ä‘á»ƒ báº­t táº¯t â€¢ ğŸ”„ Ä‘á»ƒ Ä‘áº£o camera (náº¿u há»— trá»£).</div>
        </div>
      </div>

      <div class="hgm__card">
        <div class="hgm__ic">ğŸ‘¤</div>
        <div>
          <div class="hgm__cardTitle">Co-host (KhÃ¡ch)</div>
          <div class="hgm__cardText">Cháº¥p nháº­n yÃªu cáº§u khÃ¡ch â€¢ cÃ³ thá»ƒ ğŸ”‡/ğŸ“·/â›” Ä‘iá»u khiá»ƒn khÃ¡ch.</div>
        </div>
      </div>

      <div class="hgm__card">
        <div class="hgm__ic">ğŸ‘€</div>
        <div>
          <div class="hgm__cardTitle">Link Viewer / Guest</div>
          <div class="hgm__cardText">Báº¥m ğŸ‘€ Ä‘á»ƒ copy link xem â€¢ ğŸ‘¤ Ä‘á»ƒ copy link khÃ¡ch má»i.</div>
        </div>
      </div>

      <div class="hgm__card">
        <div class="hgm__ic">ğŸ’¬</div>
        <div>
          <div class="hgm__cardTitle">Chat & Ghim</div>
          <div class="hgm__cardText">Chat realtime â€¢ Host cÃ³ thá»ƒ ğŸ“Œ ghim ná»™i dung lÃªn video.</div>
        </div>
      </div>

      <div class="hgm__card">
        <div class="hgm__ic">ğŸŸï¸</div>
        <div>
          <div class="hgm__cardTitle">Quay vá» Lobby</div>
          <div class="hgm__cardText">DÃ¹ng nÃºt â€œQuay vá» Lobbyâ€ (cÃ³ xÃ¡c nháº­n) Ä‘á»ƒ rá»i phÃ²ng.</div>
        </div>
      </div>
    </div>

    <div class="hgm__actions">
      <label class="hgm__check">
        <input type="checkbox" id="hgmDontShow" />
        <span>KhÃ´ng hiá»‡n láº¡i</span>
      </label>

      <div class="hgm__btns">
        <button id="hgmLater" class="hgm__btn hgm__btn--ghost" type="button">Äá»ƒ sau</button>
        <button id="hgmOk" class="hgm__btn hgm__btn--main" type="button">âœ… ÄÃ£ hiá»ƒu</button>
      </div>
    </div>
  </div>
</div>



<!-- LIVE STATS MODAL -->
<div id="liveStatsModal" class="ncf hidden">
  <div class="ncf__bg"></div>

  <div class="ncf__box">
    <div class="ncf__frame"></div>
    <div class="ncf__scan"></div>

    <div class="ncf__top">
      <div class="ncf__pill">
        <span class="ncf__dot"></span>
        <span>Káº¾T THÃšC LIVE</span>
      </div>
    </div>

    <h3 class="ncf__title">ğŸ“Š Thá»‘ng kÃª buá»•i live</h3>

    <div class="ncf__desc" id="liveStatsContent">
      <!-- JS render -->
    </div>

    <div class="ncf__actions">
      <span id="liveStatsCountdown">â³ Trá»Ÿ vá» lobby sau 5s</span>
    </div>
  </div>
</div>
  


<!-- GUEST REQUEST MODAL -->
<div id="guestReqModal" class="ncf hidden">
  <div class="ncf__bg"></div>

  <div class="ncf__box">
    <div class="ncf__frame"></div>

    <h3 class="ncf__title">ğŸ‘¤ KhÃ¡ch xin lÃªn live</h3>

    <div id="guestReqList" class="log">
      ChÆ°a cÃ³ yÃªu cáº§u.
    </div>

    <div class="ncf__actions">
      <button id="btnApproveGuest">âœ… Cháº¥p nháº­n</button>
      <button id="btnRejectGuest">âŒ Tá»« chá»‘i</button>
    </div>
  </div>
</div>



<!-- PIN MODAL -->
<div id="pinModal" class="ncf hidden">
  <div class="ncf__bg"></div>

  <div class="ncf__box">
    <div class="ncf__frame"></div>

    <h3 class="ncf__title">ğŸ“Œ Ghim ná»™i dung</h3>

    <input
      id="pinText"
      class="pin-input"
      placeholder="Nháº­p ná»™i dung ghim..."
      maxlength="120"
    />

    <div class="ncf__actions">
      <button id="pinSet" class="ncf__btn ncf__btn--main">ğŸ“Œ Ghim</button>
      <button id="pinClear" class="ncf__btn ncf__btn--ghost">âœ– Bá» ghim</button>
    </div>
  </div>
</div>



  <script src="/socket.io/socket.io.js"></script>
  <script>





    const guestPipWrapHost = document.getElementById("guestPipWrapHost");
    const logEl = document.getElementById("log");
    const preview = document.getElementById("preview");
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");
    const hostFlipBtn = document.getElementById("hostFlipBtn");
    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || "abc123";
   

// ===== HOST GUIDE MODAL =====
const hgm = document.getElementById("hostGuideModal");
const hgmBg = hgm?.querySelector(".hgm__bg");
const hgmX = document.getElementById("hgmX");
const hgmOk = document.getElementById("hgmOk");
const hgmLater = document.getElementById("hgmLater");
const hgmDontShow = document.getElementById("hgmDontShow");
const hgmRoom = document.getElementById("hgmRoom");

function openHgm(){
  if (!hgm) return;
  if (hgmRoom) hgmRoom.textContent = (typeof roomId !== "undefined" ? roomId : "-");
  hgm.classList.remove("hidden");
  hgm.setAttribute("aria-hidden", "false");
  setTimeout(()=>{ try{ hgmOk?.focus(); }catch{} }, 0);
}
function closeHgm(){
  if (!hgm) return;
  hgm.classList.add("hidden");
  hgm.setAttribute("aria-hidden", "true");
}
function rememberHgm(){
  if (hgmDontShow?.checked) localStorage.setItem("host_guide_off", "1");
}

// auto show on enter host
(function(){
  const off = localStorage.getItem("host_guide_off") === "1";
  if (!off) openHgm();
})();

hgmBg?.addEventListener("click", ()=>{ rememberHgm(); closeHgm(); });
hgmX?.addEventListener("click", ()=>{ rememberHgm(); closeHgm(); });
hgmLater?.addEventListener("click", ()=>{ rememberHgm(); closeHgm(); });
hgmOk?.addEventListener("click", ()=>{ rememberHgm(); closeHgm(); });

document.addEventListener("keydown", (e)=>{
  if (!hgm || hgm.classList.contains("hidden")) return;
  if (e.key === "Escape") { rememberHgm(); closeHgm(); }
});


// ===== Open Host Guide from ctrl drawer =====
const btnHostGuide = document.getElementById("btnHostGuide");
btnHostGuide?.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  if (typeof openHgm === "function") openHgm();
});


   // ===== Back to Lobby =====
// ===== NEON CONFIRM: Back to Lobby =====
const ncf = document.getElementById("neonConfirm");
const ncfBg = ncf?.querySelector(".ncf__bg");
const ncfOk = document.getElementById("ncfOk");
const ncfCancel = document.getElementById("ncfCancel");
const ncfX = document.getElementById("ncfX");

function openNcf(){
  if (!ncf) return;
  ncf.classList.remove("hidden");
  ncf.setAttribute("aria-hidden", "false");
  // focus
  setTimeout(()=>{ try{ ncfOk?.focus(); }catch{} }, 0);
}
function closeNcf(){
  if (!ncf) return;
  ncf.classList.add("hidden");
  ncf.setAttribute("aria-hidden", "true");
}

// má»Ÿ khi báº¥m nÃºt quay vá» lobby
const btnBackLobby = document.getElementById("btnBackLobby");
btnBackLobby?.addEventListener("click", () => openNcf());


// click ná»n / X / Cancel => Ä‘Ã³ng
ncfBg?.addEventListener("click", closeNcf);
ncfX?.addEventListener("click", closeNcf);
ncfCancel?.addEventListener("click", closeNcf);

// ESC Ä‘Ã³ng modal
document.addEventListener("keydown", (e)=>{
  if (!ncf || ncf.classList.contains("hidden")) return;
  if (e.key === "Escape") closeNcf();
});

// OK => dá»«ng live + vá» lobby
ncfOk?.addEventListener("click", () => {
  try {
    if (typeof socket !== "undefined" && socket && roomId) {
      socket.emit("live-stop", { roomId });
    }
  } catch {}

  window.location.href = "/lobby.html"; // home = lobby
  // hoáº·c: window.location.href = "/lobby.html";
});





// âœ… nháº­n tÃªn tá»« Lobby
const nameFromLobby = (params.get("name") || "").trim();

if(nameFromLobby){
  document.getElementById("hostNameInput").value = nameFromLobby;
}


    function toast(msg){
  const t = document.createElement("div");
  t.className = "toast";
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(()=>t.remove(), 1600);
}

    document.getElementById("roomCode").textContent = roomId;

    const viewerUrl = `${location.origin}/viewer.html?room=${encodeURIComponent(roomId)}`;
    
    document.getElementById("copyViewer").onclick = async () => {
      try { await navigator.clipboard.writeText(viewerUrl); toast("ğŸ‘€ ÄÃ£ copy link xem"); }
      catch { prompt("Copy link xem:", viewerUrl); }
    };

    // guest link
    const guestUrl = `${location.origin}/guest.html?room=${encodeURIComponent(roomId)}`;
    
    document.getElementById("copyGuest").onclick = async () => {
      try { await navigator.clipboard.writeText(guestUrl); toast("ğŸ‘¤ ÄÃ£ copy link khÃ¡ch má»i"); }
      catch { prompt("Copy link khÃ¡ch má»i:", guestUrl); }
    };

    const socket = io();
    


const voiceRequests = [];

socket.on("voice-request", ({ viewerId }) => {
  voiceRequests.push(viewerId);
  showToast(`ğŸ¤ Viewer xin nÃ³i`);
});


function approveVoice(viewerId){
  socket.emit("host-approve-voice", {
    roomId,
    viewerId
  });
}

const voicePCs = new Map();

socket.on("voice-offer", async ({ sdp, from }) => {
  const pc = new RTCPeerConnection();
  voicePCs.set(from, pc);

  pc.ontrack = e => {
    const audio = document.createElement("audio");
    audio.srcObject = e.streams[0];
    audio.autoplay = true;
    document.body.appendChild(audio);
  };

  await pc.setRemoteDescription(sdp);
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  socket.emit("voice-answer", {
    to: from,
    sdp: answer
  });
});



// ğŸ”” guest request sound
const guestReqSound = new Audio("/public/audio/sound.mp3");
guestReqSound.volume = 0.6;

let __lastGuestNotify = 0;

// ===== VIP TICKER + CHAT FREEZE + FIREWORKS =====
const vipTicker = document.getElementById("vipTicker");
let __vipQueue = [];
let __vipBusy = false;

function showVipTicker(text, ms){
  try{
    if (!vipTicker) return;
    const item = document.createElement("div");
    item.className = "vip-ticker__item";
    item.textContent = text;
    vipTicker.appendChild(item);
    // auto remove after animation
    setTimeout(()=>{ try{ item.classList.add("hide"); }catch{} }, Math.max(0, ms-350));
    setTimeout(()=>{ try{ item.remove(); }catch{} }, ms+200);
  }catch{}
}

function enqueueVip(text, ms=3000){
  __vipQueue.push({ text, ms });
  if (!__vipBusy) runVipQueue();
}

function runVipQueue(){
  if (__vipBusy) return;
  const next = __vipQueue.shift();
  if (!next) return;
  __vipBusy = true;
  showVipTicker(next.text, next.ms);
  setTimeout(()=>{
    __vipBusy = false;
    runVipQueue();
  }, next.ms + 120);
}

function freezeChat(ms=1000){
  try{
    document.body.classList.add("chat-frozen");
    setTimeout(()=>{ try{document.body.classList.remove("chat-frozen");}catch{} }, ms);
  }catch{}
}

function startVipSpotlight(ms=1200){
  try{
    // add overlay class
    document.body.classList.add("vip-spotlight");
    // zoom main card if exists
    const card = document.getElementById("hostCard") || document.getElementById("hostCardGuest");
    if (card) card.classList.add("vip-zoom");
    // remove
    setTimeout(()=>{
      try{
        document.body.classList.remove("vip-spotlight");
        if (card) card.classList.remove("vip-zoom");
      }catch{}
    }, ms);
  }catch{}
}

function spawnFireworksBurst(){
  try{
    const layer = document.createElement("div");
    layer.className = "vip-fireworks";
    document.body.appendChild(layer);

    const n = 18;
    for (let i=0;i<n;i++){
      const p = document.createElement("div");
      p.className = "vip-fireworks__p";
      p.style.left = (50 + (Math.random()*18-9))+"%";
      p.style.top  = (22 + (Math.random()*18-9))+"%";
      p.style.setProperty("--dx", (Math.random()*360-180)+"px");
      p.style.setProperty("--dy", (Math.random()*340-220)+"px");
      p.style.setProperty("--rot",(Math.random()*160-80)+"deg");
      p.style.setProperty("--sc",(Math.random()*0.9+0.7));
      layer.appendChild(p);
    }

    setTimeout(()=>{ try{layer.remove();}catch{} }, 1600);
  }catch{}
}
// ===== /VIP TICKER =====
// ===== AUTO SPEAKING HIGHLIGHT (Voice Activity) =====
function attachSpeakingIndicator(videoEl, targetEl){
  try{
    if (!videoEl || !targetEl) return;
    let ctx = null, src = null, analyser = null, data = null, raf = 0;
    let speaking = false;
    let lastOn = 0;

    function start(){
      const st = videoEl.srcObject;
      if (!st) return;
      const at = st.getAudioTracks && st.getAudioTracks()[0];
      if (!at) return; // no audio -> skip

      ctx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = ctx.createAnalyser();
      analyser.fftSize = 512;
      data = new Uint8Array(analyser.frequencyBinCount);

      src = ctx.createMediaStreamSource(new MediaStream([at]));
      src.connect(analyser);

      const TH = 16; // threshold 0..255 (tuning)
      const HOLD_MS = 450;

      const loop = ()=>{
        if (!analyser) return;
        analyser.getByteFrequencyData(data);
        let sum = 0;
        for (let i=0;i<data.length;i++) sum += data[i];
        const avg = sum / data.length;

        const now = Date.now();
        if (avg > TH){
          lastOn = now;
          if (!speaking){
            speaking = true;
            targetEl.classList.add("is-speaking");
          }
        } else {
          if (speaking && (now - lastOn) > HOLD_MS){
            speaking = false;
            targetEl.classList.remove("is-speaking");
          }
        }
        raf = requestAnimationFrame(loop);
      };
      raf = requestAnimationFrame(loop);
    }

    function stop(){
      try{ if (raf) cancelAnimationFrame(raf); }catch{}
      raf = 0;
      try{ targetEl.classList.remove("is-speaking"); }catch{}
      speaking = false;
      try{ if (src) src.disconnect(); }catch{}
      src = null;
      try{ if (ctx) ctx.close(); }catch{}
      ctx = null;
      analyser = null;
      data = null;
    }

    // restart when stream changes
    const _set = ()=>{
      stop();
      start();
    };

    // run now + also after play
    _set();
    videoEl.addEventListener("loadedmetadata", _set);
    videoEl.addEventListener("play", _set);

    // expose for manual cleanup
    videoEl.__stopSpeakingIndicator = stop;
  }catch(e){
    console.warn("attachSpeakingIndicator error:", e);
  }
}
// ===== /AUTO SPEAKING HIGHLIGHT =====

document.body.classList.add("is-host");
    // ===== CTRL TAB (collapse/expand) =====
    (function initCtrlTabHost(){
      const fab = document.getElementById("ctrlFabHost");
      const drawer = document.getElementById("ctrlDrawerHost");
      const tab = document.getElementById("ctrlTabHost");
      if (!fab || !drawer || !tab) return;

      function open(){
        drawer.hidden = false;
        tab.classList.add("is-open");
        fab.setAttribute("aria-expanded","true");
      }
      function close(){
        tab.classList.remove("is-open");
        fab.setAttribute("aria-expanded","false");
        // allow transition
        setTimeout(()=>{ drawer.hidden = !tab.classList.contains("is-open"); }, 160);
      }
      function toggle(){
        tab.classList.contains("is-open") ? close() : open();
      }

      fab.addEventListener("click", (e)=>{ e.stopPropagation(); toggle(); });
      // click outside to close
      document.addEventListener("click", (e)=>{
        if (!tab.classList.contains("is-open")) return;
        if (tab.contains(e.target)) return;
        close();
      });
      document.addEventListener("keydown", (e)=>{
        if (e.key === "Escape" && tab.classList.contains("is-open")) close();
      });
    })();
    // ===== /CTRL TAB =====



// ===== PER-PEER ICE RESTART (auto) =====
const __iceRestartState = new Map(); // peerId -> { timer, lastTs, restarting }
function __now(){ return Date.now(); }
function __clearIceTimer(peerId){
  const st = __iceRestartState.get(peerId);
  if (st && st.timer) { clearTimeout(st.timer); st.timer = null; }
}
async function __doIceRestart(peerId, pc, reason){
  if (!peerId || !pc) return;
  if (pc.signalingState === "closed") return;

  const st = __iceRestartState.get(peerId) || { timer:null, lastTs:0, restarting:false };
  // debounce: avoid spamming offers
  const ts = __now();
  if (st.restarting) return;
  if (ts - st.lastTs < 1500) return;

  st.restarting = true;
  st.lastTs = ts;
  __iceRestartState.set(peerId, st);

  try {
    log(`ğŸ§Š ICE restart -> ${peerId} (HOST) ${reason ? "- " + reason : ""}`);
    const offer = await pc.createOffer({ iceRestart: true });
    await pc.setLocalDescription(offer);
    socket.emit("offer", { to: peerId, description: pc.localDescription, iceRestart: true });
  } catch (e) {
    log("ICE restart error: " + (e?.message || e));
  } finally {
    const st2 = __iceRestartState.get(peerId) || st;
    st2.restarting = false;
    __iceRestartState.set(peerId, st2);
  }
}
function __scheduleIceRestart(peerId, pc, reason, delayMs=2200){
  if (!peerId || !pc) return;
  const st = __iceRestartState.get(peerId) || { timer:null, lastTs:0, restarting:false };
  __clearIceTimer(peerId);
  st.timer = setTimeout(()=>{
    // only restart if still not connected
    const ice = pc.iceConnectionState;
    const cs  = pc.connectionState;
    if (pc.signalingState === "closed") return;
    if (ice === "failed" || ice === "disconnected" || cs === "failed" || cs === "disconnected") {
      __doIceRestart(peerId, pc, reason);
    }
  }, delayMs);
  __iceRestartState.set(peerId, st);
}
function __wireIceAuto(peerId, pc, opts={}){
  if (!pc) return;
  const disconnectedDelay = opts.disconnectedDelay ?? 2500;

  pc.addEventListener("iceconnectionstatechange", () => {
    const st = pc.iceConnectionState;
    log(`ICE(${peerId}): ${st}`);
    if (st === "connected" || st === "completed") {
      __clearIceTimer(peerId);
      return;
    }
    if (st === "failed") {
      __scheduleIceRestart(peerId, pc, "ice failed", 50);
      return;
    }
    if (st === "disconnected") {
      __scheduleIceRestart(peerId, pc, "ice disconnected", disconnectedDelay);
      return;
    }
  });

  pc.addEventListener("connectionstatechange", () => {
    const st = pc.connectionState;
    if (!st) return;
    log(`CS(${peerId}): ${st}`);
    if (st === "connected") __clearIceTimer(peerId);
    if (st === "failed") __scheduleIceRestart(peerId, pc, "conn failed", 50);
    if (st === "disconnected") __scheduleIceRestart(peerId, pc, "conn disconnected", disconnectedDelay);
  });
}

// Restart only peers that are actually bad (NOT all)
function __restartBadPeers(getPeers){
  try {
    const peers = getPeers?.() || [];
    for (const [peerId, pc] of peers) {
      if (!pc || pc.signalingState === "closed") continue;
      const ice = pc.iceConnectionState;
      const cs = pc.connectionState;
      if (ice === "failed" || ice === "disconnected" || cs === "failed" || cs === "disconnected") {
        __doIceRestart(peerId, pc, "auto resume");
      }
    }
  } catch {}
}
// ===== /PER-PEER ICE RESTART =====

// ===== LIVE TIMER (HH:MM:SS) =====
let __liveStartTs = null;
let __liveTick = null;

function __pad2(n){ n = Math.floor(Math.max(0, n)); return String(n).padStart(2,"0"); }
function __fmtHMS(ms){
  const s = Math.floor(ms/1000);
  const hh = Math.floor(s/3600);
  const mm = Math.floor((s%3600)/60);
  const ss = s%60;
  return `${__pad2(hh)}:${__pad2(mm)}:${__pad2(ss)}`;
}
function __setTimerText(el, ms){
  if (!el) return;
  el.textContent = `â± ${__fmtHMS(ms)}`;
}
function __startTimer(el, startTs){
  __liveStartTs = startTs;
  if (__liveTick) clearInterval(__liveTick);
  __setTimerText(el, Date.now() - __liveStartTs);
  __liveTick = setInterval(()=>__setTimerText(el, Date.now() - __liveStartTs), 250);
}
function __stopTimer(el){
  __liveStartTs = null;
  if (__liveTick) clearInterval(__liveTick);
  __liveTick = null;
  if (el) el.textContent = "â± 00:00:00";
}

const liveTimerHost = document.getElementById("liveTimerHost");
socket.on("live-start", ({ startTs }) => {
  if (typeof startTs === "number") __startTimer(liveTimerHost, startTs);
});

// ğŸ”„ AUTO RESUME KHI HOST RELOAD
socket.on("live-resume", async ({ startTs }) => {
  console.log("ğŸ”„ Auto resume live");

  document.body.classList.add("is-live");


  // náº¿u reload mÃ  chÆ°a cÃ³ stream thÃ¬ má»Ÿ láº¡i camera
  if (!localStream) {
    await start(); // dÃ¹ng láº¡i hÃ m start() sáºµn cÃ³
  }

  // cháº¡y timer theo server
  if (typeof startTs === "number") {
    __startTimer(liveTimerHost, startTs);
  }

  btnStart.disabled = true;
  btnStop.disabled = false;
  hostFlipBtn.disabled = false;

    // ğŸ”„ YÃŠU Cáº¦U SERVER Gá»¬I Láº I DANH SÃCH VIEWER
  socket.emit("resume-viewers", { roomId });

});


socket.on("resume-viewers-list", async ({ viewers }) => {
  if (!Array.isArray(viewers)) return;
  console.log("ğŸ”„ Resume viewers:", viewers.length);

  for (const viewerId of viewers) {
    // náº¿u viewer chÆ°a cÃ³ PC â†’ táº¡o má»›i nhÆ° watcher
    if (!pcs.has(viewerId)) {
      socket.emit("watcher", { viewerId, roomId });
      continue;
    }

    const pc = pcs.get(viewerId);
    if (!pc || pc.signalingState === "closed") continue;

    try {
      // ğŸ”¥ ICE RESTART OFFER
      const offer = await pc.createOffer({ iceRestart: true });
      await pc.setLocalDescription(offer);
      socket.emit("offer", {
        to: viewerId,
        description: pc.localDescription,
        resume: true
      });
      log("ğŸ”„ Re-offer to viewer " + viewerId);
    } catch (e) {
      log("Resume offer error " + viewerId + ": " + e.message);
    }
  }
});



socket.on("live-stop", () => {
  __stopTimer(liveTimerHost);
});


// ===== REACTIONS (tap/click to heart) =====
function clamp01(n){ return Math.max(0, Math.min(1, n)); }
function now(){ return Date.now(); }

function attachTapToHeart(tapEl, layerEl, getRoomIdFn) {
  if (!tapEl || !layerEl) return;
  let last = 0;
  const MIN_MS = 180; // anti-spam client side

  const handler = (ev) => {
    // prevent video click from toggling play/pause
    try { if (ev && ev.cancelable) ev.preventDefault(); } catch {}
    try { ev.stopPropagation(); } catch {}
    // ignore clicks on controls/buttons/inputs
    const t = ev.target;
    if (t && (t.closest("button") || t.closest("input") || t.closest("textarea"))) return;

    const ts = now();
    if (ts - last < MIN_MS) return;
    last = ts;

    const rect = tapEl.getBoundingClientRect();
    const cx = ("clientX" in ev) ? ev.clientX : (ev.touches && ev.touches[0] ? ev.touches[0].clientX : rect.left + rect.width/2);
    const cy = ("clientY" in ev) ? ev.clientY : (ev.touches && ev.touches[0] ? ev.touches[0].clientY : rect.top + rect.height/2);
    const x = clamp01((cx - rect.left) / rect.width);
    const y = clamp01((cy - rect.top) / rect.height);

    const msg = { roomId: getRoomIdFn(), emoji: "â¤ï¸", x, y };
    // show immediately on self
    spawnReaction(layerEl, msg.emoji, msg.x, msg.y, true);
    socket.emit("reaction", msg);
  };

  tapEl.addEventListener("pointerdown", handler, { passive: false });
  // also fallback for old browsers
  tapEl.addEventListener("click", handler);
}

function spawnReaction(layerEl, emoji, x, y, local=false) {
  if (!layerEl) return;
  const el = document.createElement("div");
  el.className = "reaction-float";
  el.textContent = emoji || "â¤ï¸";
  // random motion
  const dx = (Math.random() * 120 - 60).toFixed(1); // px
  const rot = (Math.random() * 30 - 15).toFixed(1); // deg
  const sc = (0.85 + Math.random() * 0.8).toFixed(2);
  el.style.setProperty("--x", String(x));
  el.style.setProperty("--y", String(y));
  el.style.setProperty("--dx", dx + "px");
  el.style.setProperty("--rot", rot + "deg");
  el.style.setProperty("--sc", sc);
  if (local) el.classList.add("is-local");
  layerEl.appendChild(el);
  setTimeout(()=>{ try{ el.remove(); }catch{} }, 1800);
}

socket.on("reaction", (msg)=>{
  try {
    if (!msg) return;
    const emoji = msg.emoji || "â¤ï¸";
    const x = clamp01(Number(msg.x ?? 0.5));
    const y = clamp01(Number(msg.y ?? 0.7));
    // choose layer based on whether it's guest/host layer (we only have one layer per page for now)
    const layer = document.getElementById("reactionsLayerHost");
    spawnReaction(layer, emoji, x, y, false);
  } catch (e) {
    console.warn("reaction render error", e);
  }
});

// ===== INIT TAP-TO-HEART on main live card =====
(function initTapHearts(){
  const __tapEl = document.getElementById("hostCard");
  const __layerEl = document.getElementById("reactionsLayerHost");
  if (!__tapEl || !__layerEl) return;
  attachTapToHeart(__tapEl, __layerEl, ()=>roomId);
})();



    let localStream = null;
    let currentFacing = "user"; // user | environment

    // One RTCPeerConnection per viewer
    const pcs = new Map();

    // When network comes back / tab returns, restart only bad peers
    window.addEventListener("online", () => __restartBadPeers(() => Array.from(pcs.entries())));
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "visible") __restartBadPeers(() => Array.from(pcs.entries()));
    });


    // Guest state
   
    let approvedGuestId = null;
    let pcGuestIn = null; // PC to receive guest + send host tracks to guest
   
    
    const guestVideo = document.getElementById("guestVideo");

    async function getRtcConfig() {
      const fallback = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

      try {
        const r = await fetch("/ice", { cache: "no-store" });
        if (!r.ok) return fallback;

        const data = await r.json();
        if (!data.iceServers || !Array.isArray(data.iceServers)) return fallback;

        const cleanedIceServers = data.iceServers
          .map(server => {
            let urls = server.urls;
            if (!urls) return null;
            if (!Array.isArray(urls)) urls = [urls];

            // remove invalid STUN urls that contain ?transport=
            const safeUrls = urls.filter(u =>
              typeof u === "string" &&
              !(u.startsWith("stun:") && u.includes("?transport="))
            );
            if (safeUrls.length === 0) return null;
            return { ...server, urls: safeUrls };
          })
          .filter(Boolean);

        if (cleanedIceServers.length === 0) return fallback;
        return { iceServers: cleanedIceServers };
      } catch (e) {
        console.error("ICE fetch error:", e);
        return fallback;
      }
    }

    function log(msg) {
      logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

    function getHostProfile() {
  let name = localStorage.getItem("hostName") || "";
  if (!name) {
    name = prompt("Nháº­p tÃªn host hiá»ƒn thá»‹ trÃªn sáº£nh chá»:", "Host") || "Host";
    name = name.trim().slice(0, 20) || "Host";
    localStorage.setItem("hostName", name);
  }

  // Avatar máº·c Ä‘á»‹nh (pravatar) â€” Ä‘á»•i theo tÃªn Ä‘á»ƒ má»—i host khÃ¡c nhau
  let avatar = localStorage.getItem("hostAvatar") || "";
  if (!avatar) {
    avatar = `https://img.freepik.com/premium-vector/live-streaming-text-neon-sign-illustration_189374-265.jpg?w=360`;
    localStorage.setItem("hostAvatar", avatar);
  }

  return { name, avatar };
}

const hostProfile = getHostProfile();

socket.emit("join-room", {
  roomId,
  role: "broadcaster",
  profile: hostProfile
});


    // Peer asks HOST to ICE-restart this connection (HOST is offerer for viewers)
    socket.on("request-ice-restart", async ({ from, reason }) => {
      const peerId = from;
      const pc = pcs.get(peerId);
      if (pc) __doIceRestart(peerId, pc, reason || "requested");
    });


    // ===== Viewer -> Host streaming =====
    socket.on("watcher", async ({ viewerId }) => {
      if (!localStream) {
        log("CÃ³ viewer nhÆ°ng báº¡n chÆ°a Start camera.");
        return;
      }
      if (pcs.has(viewerId)) return;

      log(`Viewer join: ${viewerId}`);

      const rtcConfig = await getRtcConfig();
      const pc = new RTCPeerConnection(rtcConfig);
      pcs.set(viewerId, pc);


      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      pc.onicecandidate = (e) => {
        if (e.candidate) socket.emit("candidate", { to: viewerId, candidate: e.candidate });
      };

            __wireIceAuto(viewerId, pc);

      try {
        const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
        await pc.setLocalDescription(offer);
        socket.emit("offer", { to: viewerId, description: pc.localDescription });
      } catch (err) {
        log("Lá»—i táº¡o offer: " + err.message);
      }
    });

    socket.on("answer", async ({ from, description }) => {
      // could be viewer answer OR guest answer (rare in this flow)
      const pc = pcs.get(from);
      if (pc) {
        try {
          await pc.setRemoteDescription(description);
          log(`Nháº­n answer tá»«: ${from}`);
        } catch (err) {
          log("Lá»—i setRemoteDescription(answer): " + err.message);
        }
        return;
      }
      if (pcGuestIn && approvedGuestId === from) {
        try {
          await pcGuestIn.setRemoteDescription(description);
          log("Nháº­n answer tá»« guest: " + from);
        } catch (err) {
          log("Lá»—i answer guest: " + err.message);
        }
      }
    });

    socket.on("candidate", async ({ from, candidate }) => {
      const pc = pcs.get(from);
      if (pc) {
        try { await pc.addIceCandidate(candidate); }
        catch (err) { log("Lá»—i addIceCandidate(viewer): " + err.message); }
        return;
      }
      if (pcGuestIn && approvedGuestId === from) {
        try { await pcGuestIn.addIceCandidate(candidate); }
        catch (err) { log("Lá»—i addIceCandidate(guest): " + err.message); }
      }
    });

    

// ===== ICE RESTART: host regenerates offer when asked =====
socket.on('request-ice-restart', async ({ from, reason })=>{
  try{
    // from viewer
    const pc = pcs.get(from);
    if (pc){
      const offer = await pc.createOffer({ iceRestart: true });
      await pc.setLocalDescription(offer);
      socket.emit('offer', { to: from, description: pc.localDescription });
      log('ICE restart -> new offer to viewer ' + from + (reason ? ' ('+reason+')' : ''));
      return;
    }
    // from guest (if guest asks host)
    if (pcGuestIn && approvedGuestId === from){
      const offer = await pcGuestIn.createOffer({ iceRestart: true });
      await pcGuestIn.setLocalDescription(offer);
      socket.emit('offer', { to: from, description: pcGuestIn.localDescription });
      log('ICE restart -> new offer to guest ' + from + (reason ? ' ('+reason+')' : ''));
      return;
    }
  }catch(e){ log('ICE restart error: ' + (e?.message||e)); }
});
// ===== /ICE RESTART =====
socket.on("disconnectPeer", ({ peerId }) => {
      const pc = pcs.get(peerId);
      if (pc) {
        pc.close();
        pcs.delete(peerId);
        log(`Viewer rá»i: ${peerId} -> close peer`);
      }
    });


const guestReqIcon  = document.getElementById("guestReqIcon");
const guestReqDot   = document.getElementById("guestReqDot");
const guestReqModal = document.getElementById("guestReqModal");
const guestReqList  = document.getElementById("guestReqList");
const btnApproveGuest = document.getElementById("btnApproveGuest");
const btnRejectGuest  = document.getElementById("btnRejectGuest");

let pendingGuestId = null;

// má»Ÿ modal khi báº¥m icon
guestReqIcon.onclick = () => {
  guestReqModal.classList.remove("hidden");
};

// click ná»n Ä‘Ã³ng modal
guestReqModal.querySelector(".ncf__bg").onclick = () => {
  guestReqModal.classList.add("hidden");
};

// ğŸ”” khi cÃ³ guest xin live
socket.on("guest-request", ({ guestId }) => {
  pendingGuestId = guestId;

  guestReqIcon.classList.add("has-request");
  guestReqList.textContent = `ğŸ‘¤ Guest ID: ${guestId}`;

  btnApproveGuest.disabled = false;
  btnRejectGuest.disabled = false;

  // ===== ğŸ”” RUNG + Ã‚M THANH =====
  const now = Date.now();
  if (now - __lastGuestNotify > 1200) {
    __lastGuestNotify = now;

    // rung icon
    guestReqIcon.classList.remove("is-shake");
    void guestReqIcon.offsetWidth; // reset animation
    guestReqIcon.classList.add("is-shake");

    // phÃ¡t Ã¢m thanh
    try {
      guestReqSound.currentTime = 0;
      guestReqSound.play().catch(()=>{});
    } catch {}
  }

});


    socket.on("guest-offline", () => {
      log("Guest offline");
      approvedGuestId = null;
      pendingGuestId = null;
      guestReqIcon.classList.remove("has-request");
      guestReqModal.classList.add("hidden");
      btnApproveGuest.disabled = true;
      btnRejectGuest.disabled = true;
      if (pcGuestIn) { try { pcGuestIn.close(); } catch {} pcGuestIn = null; }
      guestVideo.srcObject = null;
    });

    btnApproveGuest.onclick = () => {
    if (!pendingGuestId) return;
    socket.emit("guest-approve", {
    roomId,
    guestId: pendingGuestId
    });



  // reset UI
  guestReqIcon.classList.remove("has-request", "is-shake");
  guestReqModal.classList.add("hidden");
  guestReqList.textContent = "ÄÃ£ duyá»‡t guest";

  pendingGuestId = null;
  btnApproveGuest.disabled = true;
  btnRejectGuest.disabled = true;

  // yÃªu cáº§u guest gá»­i offer
  socket.emit("watch-guest", { roomId });
};

  btnRejectGuest.onclick = () => {
  if (!pendingGuestId) return;
  socket.emit("guest-reject", {
  guestId: pendingGuestId
  });

  // reset UI
  guestReqIcon.classList.remove("has-request", "is-shake");
  guestReqModal.classList.add("hidden");
  guestReqList.textContent = "ÄÃ£ tá»« chá»‘i guest";

  pendingGuestId = null;
  btnApproveGuest.disabled = true;
  btnRejectGuest.disabled = true;
};


document.addEventListener("pointerdown", () => {
  guestReqSound.play().then(()=>guestReqSound.pause()).catch(()=>{});
}, { once:true });


    // Host receives OFFER from guest (guest creates offer to everyone who "watch-guest")
    socket.on("offer", async ({ from, description }) => {
      // Only handle guest offers (viewers never send offers to host in this app)
      approvedGuestId = approvedGuestId || from;

      if (pcGuestIn) { try { pcGuestIn.close(); } catch {} pcGuestIn = null; }

      const rtcConfig = await getRtcConfig();
      pcGuestIn = new RTCPeerConnection(rtcConfig);

      // send host tracks back to guest so guest can hear/see host (co-talk)
      if (localStream) {
        localStream.getTracks().forEach(t => pcGuestIn.addTrack(t, localStream));
      }

      pcGuestIn.ontrack = (e) => {
        guestVideo.srcObject = e.streams[0];
        try{ attachSpeakingIndicator(guestVideo, document.getElementById('guestPipWrapHost')); }catch{}
      };

      pcGuestIn.onicecandidate = (e) => {
        if (e.candidate) socket.emit("candidate", { to: from, candidate: e.candidate });
      };

            pcGuestIn.addEventListener("iceconnectionstatechange", () => {
        const st = pcGuestIn.iceConnectionState;
        log(`ICE(GUEST): ${st}`);
        if (st === "failed" || st === "disconnected") {
          if (approvedGuestId) socket.emit("request-ice-restart", { to: approvedGuestId, reason: "guest link " + st });
        }
      });

      try {
        await pcGuestIn.setRemoteDescription(description);
        const answer = await pcGuestIn.createAnswer();
        await pcGuestIn.setLocalDescription(answer);
        socket.emit("answer", { to: from, description: pcGuestIn.localDescription });
        log("ÄÃ£ tráº£ lá»i offer cá»§a guest: " + from);
      } catch (err) {
        log("Lá»—i xá»­ lÃ½ offer guest: " + err.message);
      }
    });

    // ===== Start/Stop/Flip =====
    async function start() {
      if (localStream) return;

      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { ideal: currentFacing } },
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        });

        preview.srcObject = localStream;

// âœ… Báº¬T TRáº NG THÃI LIVE
    document.body.classList.add("is-live");


    try{ attachSpeakingIndicator(preview, document.getElementById('hostCard')); }catch{}
        btnStart.disabled = true;
        btnStop.disabled = false;
        hostFlipBtn.disabled = false;


        log("ÄÃ£ Start camera + mic. Gá»­i link xem cho ngÆ°á»i khÃ¡c.");
        socket.emit("broadcaster-ready", { roomId });
        socket.emit("live-start", { roomId });

      } catch (err) {
        log("KhÃ´ng má»Ÿ Ä‘Æ°á»£c camera/mic: " + err.message);
        alert("KhÃ´ng má»Ÿ Ä‘Æ°á»£c camera/mic. Náº¿u trÃªn Ä‘iá»‡n thoáº¡i: cáº§n HTTPS.");
      }
    }

    function stop() {
      // close all viewer peers
      for (const [id, pc] of pcs.entries()) {
        try { pc.close(); } catch {}
        pcs.delete(id);
      }

      // close guest peer
      if (pcGuestIn) { try { pcGuestIn.close(); } catch {} pcGuestIn = null; }
      guestVideo.srcObject = null;

      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      preview.srcObject = null;

  // âŒ Táº®T TRáº NG THÃI LIVE
  document.body.classList.remove("is-live");

  // reset icon guest
  guestReqIcon.classList.remove("has-request");

      btnStart.disabled = false;
      btnStop.disabled = true;
      hostFlipBtn.disabled = true;


      socket.emit("live-stop", { roomId });

      log("ÄÃ£ Stop.");
    }

    async function flipCamera() {
      if (!localStream) return;

      currentFacing = (currentFacing === "user") ? "environment" : "user";
      log("Äang Ä‘á»•i camera sang: " + (currentFacing === "user" ? "CAM TRÆ¯á»šC" : "CAM SAU"));

      try {
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: { ideal: currentFacing } },
          audio: false
        });

        const newVideoTrack = newStream.getVideoTracks()[0];
        if (!newVideoTrack) throw new Error("KhÃ´ng láº¥y Ä‘Æ°á»£c video track má»›i");

        const oldVideoTrack = localStream.getVideoTracks()[0];
        if (oldVideoTrack) {
          localStream.removeTrack(oldVideoTrack);
          oldVideoTrack.stop();
        }
        localStream.addTrack(newVideoTrack);
        preview.srcObject = localStream;
    try{ attachSpeakingIndicator(preview, document.getElementById('hostCard')); }catch{}

        // replace for all viewer peers
        for (const [viewerId, pc] of pcs.entries()) {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender) await sender.replaceTrack(newVideoTrack);
        }

        // replace for guest peer
        if (pcGuestIn) {
          const sender = pcGuestIn.getSenders().find(s => s.track && s.track.kind === "video");
          if (sender) await sender.replaceTrack(newVideoTrack);
        }

        log("âœ… Äá»•i camera thÃ nh cÃ´ng.");
      } catch (err) {
        log("âŒ Äá»•i camera tháº¥t báº¡i: " + err.message);
        currentFacing = (currentFacing === "user") ? "environment" : "user";
        alert("KhÃ´ng Ä‘á»•i Ä‘Æ°á»£c camera. HÃ£y kiá»ƒm tra quyá»n camera.");
      }
    }

    btnStart.onclick = start;
    btnStop.onclick = stop;
    hostFlipBtn.onclick = flipCamera;

    window.addEventListener("beforeunload", stop);




// ===== PIN (Ghim ná»™i dung) =====
const btnPinToggle = document.getElementById("btnPinToggle");
const pinModal = document.getElementById("pinModal");
const pinBg = pinModal?.querySelector(".ncf__bg");
const pinText = document.getElementById("pinText");
const pinSet = document.getElementById("pinSet");
const pinClear = document.getElementById("pinClear");

// má»Ÿ modal khi báº¥m icon ğŸ“Œ
btnPinToggle?.addEventListener("click", () => {
  pinModal.classList.remove("hidden");
  setTimeout(() => pinText?.focus(), 0);
});

// click ná»n Ä‘á»ƒ Ä‘Ã³ng
pinBg?.addEventListener("click", () => {
  pinModal.classList.add("hidden");
});

// ghim
pinSet?.addEventListener("click", () => {
  const text = pinText.value.trim();
  if (!text) return;

  socket.emit("pin-set", { roomId, text });
  pinModal.classList.add("hidden");
});

// bá» ghim
pinClear?.addEventListener("click", () => {
  socket.emit("pin-clear", { roomId });
  pinText.value = "";
  pinModal.classList.add("hidden");
});



socket.on("pin-update", (text) => {
  pinOverlay.textContent = text || "";
});




    // ===== PIN NOTE (Host-created draggable overlay) =====
const pinOverlay = document.getElementById("pinOverlay");
const hostCard = document.getElementById("hostCard");

let __pinState = null;
let __drag = null;
let __lastEmit = 0;

function __clamp01(n){ n = Number(n); if (!isFinite(n)) return 0.5; return Math.max(0, Math.min(1, n)); }

function renderPin(note){
  __pinState = note || null;
  if (!pinOverlay) return;
  pinOverlay.innerHTML = "";
  if (!note) return;

  const wrap = document.createElement("div");
  wrap.className = "pin-note";
  wrap.style.left = (__clamp01(note.x) * 100).toFixed(3) + "%";
  wrap.style.top  = (__clamp01(note.y) * 100).toFixed(3) + "%";

  const head = document.createElement("div");
  head.className = "pin-head";

  const title = document.createElement("div");
  title.className = "pin-title";
  title.innerHTML = ``;

  const hint = document.createElement("div");
  hint.className = "pin-hint";
  hint.textContent = "";

  const close = document.createElement("button");
  close.className = "pin-close";
  close.type = "button";
  close.textContent = "âœ–";
  close.title = "Bá» ghim";
  close.addEventListener("click", (e)=>{
    e.preventDefault(); e.stopPropagation();
    socket.emit("pin-note-clear", { roomId });
  });

  head.appendChild(title);
  head.appendChild(hint);
  head.appendChild(close);

  const body = document.createElement("div");
  body.className = "pin-body";
  body.textContent = String(note.text || "");

  wrap.appendChild(head);
  wrap.appendChild(body);
  pinOverlay.appendChild(wrap);

  // enable dragging (host only)
  wireDrag(wrap);
}

function wireDrag(el){
  if (!el || !hostCard) return;

  const onDown = (ev)=>{
    // don't drag when clicking close
    if (ev.target && ev.target.closest(".pin-close")) return;
    try { el.setPointerCapture(ev.pointerId); } catch {}
    const rect = hostCard.getBoundingClientRect();
    const px = ("clientX" in ev) ? ev.clientX : 0;
    const py = ("clientY" in ev) ? ev.clientY : 0;
    __drag = { rect, startX: px, startY: py };
  };

  const onMove = (ev)=>{
    if (!__drag || !__pinState || !hostCard) return;
    const rect = hostCard.getBoundingClientRect();
    const px = ("clientX" in ev) ? ev.clientX : 0;
    const py = ("clientY" in ev) ? ev.clientY : 0;
    const x = __clamp01((px - rect.left) / rect.width);
    const y = __clamp01((py - rect.top) / rect.height);

    // update locally for smooth drag
    el.style.left = (x * 100).toFixed(3) + "%";
    el.style.top  = (y * 100).toFixed(3) + "%";
    __pinState.x = x; __pinState.y = y;

    // throttle emit so viewers see it moving
    const t = Date.now();
    if (t - __lastEmit > 80) {
      __lastEmit = t;
      socket.emit("pin-note-move", { roomId, x, y });
    }
  };

  const onUp = (ev)=>{
    if (!__drag || !__pinState || !hostCard) { __drag = null; return; }
    __drag = null;
    // final sync
    socket.emit("pin-note-move", { roomId, x: __pinState.x, y: __pinState.y });
  };

  el.addEventListener("pointerdown", onDown);
  el.addEventListener("pointermove", onMove);
  el.addEventListener("pointerup", onUp);
  el.addEventListener("pointercancel", onUp);
  el.addEventListener("lostpointercapture", onUp);

  // quick edit by double click
  el.addEventListener("dblclick", (e)=>{
    e.preventDefault(); e.stopPropagation();
    const next = prompt("Sá»­a ná»™i dung ghim:", String(__pinState?.text || ""));
    if (next == null) return;
    const t = String(next).trim();
    if (!t) return;
    pinText && (pinText.value = t);
    socket.emit("pin-note-set", { roomId, text: t, x: __pinState?.x ?? 0.5, y: __pinState?.y ?? 0.2 });
  });
}

// Host set/clear
if (pinSet) pinSet.onclick = ()=>{
  const text = String(pinText?.value || "").trim();
  if (!text) return;
  const x = __pinState?.x ?? 0.5;
  const y = __pinState?.y ?? 0.2; // near top
  socket.emit("pin-note-set", { roomId, text, x, y });
};
if (pinClear) pinClear.onclick = ()=> socket.emit("pin-note-clear", { roomId });

// Receive updates
socket.on("pin-note-update", (note)=> renderPin(note));
// ===== /PIN NOTE =====

    // ===== CHAT (BROADCAST) =====
    const chatBox = document.getElementById("chatBox");
    const chatName = document.getElementById("chatName");
    const chatText = document.getElementById("chatText");
    const chatSend = document.getElementById("chatSend");

    function addChat(msg) {
      const time = new Date(msg.ts).toLocaleTimeString();
      const role = String(msg.role || "viewer");
      const tag = role === "host" ? "[HOST]" : role === "guest" ? "[GUEST]" : "";
      const line = document.createElement("div");
      line.className = "chat-line chat-" + role;
      line.textContent = `[${time}] ${tag ? tag + " " : ""}${msg.name}: ${msg.text}`;
      chatBox.appendChild(line);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    socket.on("chat", (msg)=>{ addChat(msg); pushOverlay(msg); });



    // ===== CHAT OVERLAY + EMOJI QUICK BAR ===== // CHAT OVERLAY
    const chatOverlay = document.getElementById("chatOverlay");
    function pushOverlay(msg){
      if (!chatOverlay) return;
      const role = String(msg.role || "viewer");
      const tag = role === "host" ? "[HOST]" : role === "guest" ? "[GUEST]" : "";
      const el = document.createElement("div");
      el.className = "chat-bubble chat-" + role;
      el.textContent = `${tag ? tag + " " : ""}${msg.name}: ${msg.text}`;
      chatOverlay.appendChild(el);

      // keep only last 4 bubbles
      while (chatOverlay.children.length > 4) chatOverlay.removeChild(chatOverlay.firstChild);

      // auto fade + remove
      setTimeout(() => el.classList.add("hide"), 2600);
      setTimeout(() => { try { el.remove(); } catch {} }, 3200);
    }

    // add emoji buttons
    const emojiBar = document.getElementById("emojiBar");
    if (emojiBar) {
      emojiBar.addEventListener("click", (e) => {
        const btn = e.target.closest("[data-emoji]");
        if (!btn) return;
        const em = btn.getAttribute("data-emoji") || "";
        chatText.value = (chatText.value || "") + em;
        chatText.focus();
      });
    }


    chatSend.onclick = () => {
      const name = (chatName.value || "Host").trim();
      const text = chatText.value.trim();
      if (!text) return;

      socket.emit("chat", { roomId, name, text, role: "host" });
      chatText.value = "";
    };

// ===== HOST AV TOGGLE =====
const hostMicBtn = document.getElementById("hostMicBtn");
const hostCamBtn = document.getElementById("hostCamBtn");

let hostMicOn = true;
let hostCamOn = true;

function toggleHostMic(){
  if (!localStream) return;
  const track = localStream.getAudioTracks()[0];
  if (!track) return;

  hostMicOn = !hostMicOn;
  track.enabled = hostMicOn;
  hostMicBtn.classList.toggle("off", !hostMicOn);
  hostMicBtn.textContent = hostMicOn ? "ğŸ™ï¸" : "ğŸ”‡";
}

function toggleHostCam(){
  if (!localStream) return;
  const track = localStream.getVideoTracks()[0];
  if (!track) return;

  hostCamOn = !hostCamOn;
  track.enabled = hostCamOn;
  hostCamBtn.classList.toggle("off", !hostCamOn);
  hostCamBtn.textContent = hostCamOn ? "ğŸ“·" : "ğŸš«";
}

hostMicBtn.onclick = toggleHostMic;
hostCamBtn.onclick = toggleHostCam;

    
const btnMuteGuest = document.getElementById("btnMuteGuest");
const btnUnmuteGuest = document.getElementById("btnUnmuteGuest");
const btnKickGuest = document.getElementById("btnKickGuest");
const btnOffCamGuest = document.getElementById("btnOffCamGuest");
const btnOnCamGuest  = document.getElementById("btnOnCamGuest");

function setGuestControls(on) {
  btnMuteGuest.disabled = !on;
  btnUnmuteGuest.disabled = !on;
  btnOffCamGuest.disabled = !on;
  btnOnCamGuest.disabled = !on;
  btnKickGuest.disabled = !on;
}

// nÃºt Ä‘iá»u khiá»ƒn
btnOffCamGuest.onclick = () => socket.emit("host-cam-guest", { roomId, off: true });
btnOnCamGuest.onclick  = () => socket.emit("host-cam-guest", { roomId, off: false });

// khi host cháº¥p nháº­n guest xong (hoáº·c khi guest-online), báº­t controls
socket.on("guest-online", ({ guestId }) => {

  document.body.classList.add("has-guest");
if (guestPipWrapHost) guestPipWrapHost.setAttribute("aria-hidden", "false");

  setGuestControls(true);
});

// khi guest-offline thÃ¬ táº¯t controls
socket.on("guest-offline", () => {

 document.body.classList.remove("has-guest");

if (guestPipWrapHost) guestPipWrapHost.setAttribute("aria-hidden", "true");

  setGuestControls(false);
});

// nÃºt Ä‘iá»u khiá»ƒn
btnMuteGuest.onclick = () => socket.emit("host-mute-guest", { roomId, mute: true });
btnUnmuteGuest.onclick = () => socket.emit("host-mute-guest", { roomId, mute: false });
btnKickGuest.onclick = () => socket.emit("host-kick-guest", { roomId });
btnOffCamGuest.onclick = () => socket.emit("host-cam-guest", { roomId, off: true });
btnOnCamGuest.onclick  = () => socket.emit("host-cam-guest", { roomId, off: false });

const viewerCountHost = document.getElementById("viewerCountHost");


const joinOverlayHost = document.getElementById("joinOverlayHost");
function pushJoinHost(text){
  if (!joinOverlayHost) return;
  const el = document.createElement("div");
  el.className = "join-bubble";
  el.textContent = text;
  joinOverlayHost.appendChild(el);
  while (joinOverlayHost.children.length > 3) joinOverlayHost.removeChild(joinOverlayHost.firstChild);
  setTimeout(()=>el.classList.add("hide"), 1400);
  setTimeout(()=>{ try{el.remove();}catch{} }, 2000);
}
socket.on("viewer-join", () => pushJoinHost("â• +1 ngÆ°á»i xem"));
socket.on("viewer-leave", () => pushJoinHost("â– -1 ngÆ°á»i xem"));

socket.on("viewer-count", ({ count }) => {
  if (viewerCountHost) {
    viewerCountHost.textContent = `ğŸ‘: ${count}`;
  
    try { viewerCountHost.classList.remove("pulse"); void viewerCountHost.offsetWidth; viewerCountHost.classList.add("pulse"); } catch {}}
});


const giftLayer = document.getElementById("giftLayer");
const giftTotalCoinsHost = document.getElementById("giftTotalCoinsHost");
const giftTopListHost = document.getElementById("giftTopListHost");
socket.on("gift-stats", ({ totalCoins, topDonors })=>{
  if (giftTotalCoinsHost) giftTotalCoinsHost.textContent = String(totalCoins ?? 0);
  if (giftTopListHost){
    const arr = Array.isArray(topDonors) ? topDonors : [];
    giftTopListHost.innerHTML = arr.length
      ? arr.map((d,i)=>`<div class="gift-board__row"><span>#${i+1} ${d.name}</span><b>${d.coins}</b></div>`).join("")
      : `<div class="gift-board__empty">ChÆ°a cÃ³ donate</div>`;
  }
});


function spawnGift(type, donor, giftMeta){
  const el = document.createElement("div");
  el.className = "gift-item";

  el.textContent =
    type === "heart"  ? "â¤ï¸" :
    type === "flower" ? "ğŸŒ¸" :
    type === "rocket" ? "ğŸš€" :
    "ğŸ’°";

  el.style.left = Math.random()*80 + 10 + "%";
  el.style.bottom = "10%";

  giftLayer.appendChild(el);
  setTimeout(()=>el.remove(), 2000);
}

socket.on("gift", ({ gift, donor })=>{
  spawnGift(gift.type, donor, gift);
  try{
    const note = document.createElement("div");
    note.className = "gift-toast";
    const em = gift.emoji || "ğŸ";
    note.textContent = `${em} ${donor || "Ai Ä‘Ã³"} donate +${gift.coins || 0} coin`;
    document.body.appendChild(note);
    setTimeout(()=>note.classList.add("hide"), 1600);
    setTimeout(()=>{ try{note.remove();}catch{} }, 2300);
  }catch{}
});
const hostNameInput = document.getElementById("hostNameInput");
const btnUpdateProfile = document.getElementById("btnUpdateProfile");

btnUpdateProfile.onclick = () => {
  const name = hostNameInput.value.trim().slice(0, 20);
  if (!name) return toast("âŒ ChÆ°a nháº­p tÃªn");

  socket.emit("host-update-profile", {
    roomId,
    name
  });

  toast("âœ… ÄÃ£ cáº­p nháº­t tÃªn host");
};

// âœ… náº¿u Ä‘i tá»« Lobby qua thÃ¬ auto fill + auto update luÃ´n
if (nameFromLobby) {
  hostNameInput.value = nameFromLobby.slice(0, 20);

  // Ä‘á»£i socket connect xong rá»“i emit
  if (socket.connected) {
    btnUpdateProfile.onclick();
  } else {
    socket.on("connect", () => btnUpdateProfile.onclick());
  }
}

const chatFab = document.getElementById("chatFab");
const chatInputOverlay = document.getElementById("chatInputOverlay");
const quickChatInput = document.getElementById("quickChatInput");
const quickChatSend = document.getElementById("quickChatSend");

// âœ… iOS/Android: pháº£i focus trong cÃ¹ng â€œuser gestureâ€
function openQuickChat(){
  chatInputOverlay.classList.remove("hidden");
  quickChatInput.focus({ preventScroll: false });
  quickChatInput.click();         // âœ… Ã©p báº­t keyboard (Android)
  quickChatInput.scrollIntoView({ block:"nearest" });
}

function closeQuickChat(){
  chatInputOverlay.classList.add("hidden");
  quickChatInput.blur();
}

chatFab?.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  e.stopPropagation();

  if (chatInputOverlay.classList.contains("hidden")) openQuickChat();
  else closeQuickChat();
});

quickChatSend?.addEventListener("pointerdown", (e)=>{
  e.preventDefault();
  sendQuickChat();
});

quickChatInput?.addEventListener("keydown", (e)=>{
  if (e.key === "Enter") sendQuickChat();
});

function sendQuickChat(){
  const text = (quickChatInput.value || "").trim();
  if (!text) return;

  socket.emit("chat", {
    roomId,
    name: (chatName?.value || "User").trim(),
    text,
    // role tÃ¹y trang báº¡n set:
    // role: "host" / "viewer" / "guest"
  });

  quickChatInput.value = "";
  closeQuickChat();
}


const liveStatsModal = document.getElementById("liveStatsModal");
const liveStatsContent = document.getElementById("liveStatsContent");
const liveStatsCountdown = document.getElementById("liveStatsCountdown");

function fmtTime(ms){
  const s = Math.floor(ms/1000);
  const m = Math.floor(s/60);
  const r = s%60;
  return `${m} phÃºt ${r} giÃ¢y`;
}

socket.on("live-ended-stats", (stats) => {
  // render ná»™i dung
  liveStatsContent.innerHTML = `
    <div>â± Thá»i gian live: <b>${fmtTime(stats.durationMs)}</b></div>
    <div>ğŸ‘ NgÆ°á»i xem: <b>${stats.viewers}</b></div>
    <div>ğŸ‘¤ CÃ³ guest: <b>${stats.hasGuest ? "CÃ³" : "KhÃ´ng"}</b></div>
  `;

  // show modal
  liveStatsModal.classList.remove("hidden");

  // â³ countdown vá» lobby
  let sec = 10;
  liveStatsCountdown.textContent = `â³ Trá»Ÿ vá» lobby sau ${sec}s`;

  const t = setInterval(() => {
    sec--;
    liveStatsCountdown.textContent = `â³ Trá»Ÿ vá» lobby sau ${sec}s`;
    if (sec <= 0) {
      clearInterval(t);
      location.href = "/lobby.html";
    }
  }, 1000);
});



  // Cháº·n pinch zoom (iOS)
  document.addEventListener("gesturestart", e => e.preventDefault());
  document.addEventListener("gesturechange", e => e.preventDefault());
  document.addEventListener("gestureend", e => e.preventDefault());

  // Cháº·n Ctrl + scroll zoom (PC)
  document.addEventListener("wheel", e => {
    if (e.ctrlKey) e.preventDefault();
  }, { passive: false });




  function getUserProfile(){
  const p = localStorage.getItem("user_profile");
  if (!p) return null;
  try { return JSON.parse(p); }
  catch { return null; }
}


const profile = getUserProfile();
if (profile){
  const hostNameInput = document.getElementById("hostNameInput");
  const avatar = document.getElementById("hostAvatarPreview");

  if (hostNameInput){
    hostNameInput.value = profile.name;
    hostNameInput.disabled = true;
  }

  if (avatar){
    avatar.src = profile.avatar;
  }
}



  </script>





<!-- VIP TICKER (donation banner) -->
<div id="vipTicker" class="vip-ticker" aria-live="polite"></div>

</body>
</html>
