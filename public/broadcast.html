<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Broadcast</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>üì± Broadcast (Ng∆∞·ªùi ph√°t)</h1>
      <small>M·ªü tr√™n ƒëi·ªán tho·∫°i v√† b·∫•m Start ƒë·ªÉ ph√°t live.</small>
      <hr />

      <div class="row">
        <div class="card">
          <div class="kv">
            <div class="badge">Ph√≤ng</div>
            <code id="roomCode">-</code>

            <div class="badge">Link xem</div>
            <code id="viewerLink">-</code>
            <button id="copyViewer">Copy link xem</button>

            <hr />
            <button id="btnStart">Start Camera + Mic</button>
            <button id="btnStop" disabled>Stop</button>
          </div>
          <hr />
          <div class="log" id="log"></div>
        </div>

        <div class="card">
          <div class="badge">Preview</div>
          <div class="video-wrap" style="margin-top:10px">
            <!-- muted ƒë·ªÉ preview t·ª± ch·∫°y tr√™n mobile -->
            <video id="preview" autoplay playsinline muted></video>
          </div>
          <small>Preview lu√¥n muted ƒë·ªÉ tr√°nh b·ªã ch·∫∑n autoplay.</small>
        </div>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const logEl = document.getElementById("log");
    const preview = document.getElementById("preview");
    const btnStart = document.getElementById("btnStart");
    const btnStop = document.getElementById("btnStop");

    const params = new URLSearchParams(location.search);
    const roomId = params.get("room") || "abc123";

    document.getElementById("roomCode").textContent = roomId;

    const viewerUrl = `${location.origin}/viewer.html?room=${encodeURIComponent(roomId)}`;
    document.getElementById("viewerLink").textContent = viewerUrl;
    document.getElementById("copyViewer").onclick = async () => {
      try { await navigator.clipboard.writeText(viewerUrl); alert("ƒê√£ copy link xem!"); }
      catch { prompt("Copy th·ªß c√¥ng:", viewerUrl); }
    };

    const socket = io();
    let localStream = null;

    // One RTCPeerConnection per viewer
    const pcs = new Map();

    // STUN server (demo). TURN s·∫Ω c·∫ßn n·∫øu m·∫°ng kh√≥ (4G/Carrier NAT)
async function getRtcConfig() {
  const fallback = {
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  };

  try {
    const r = await fetch("/ice", { cache: "no-store" });
    if (!r.ok) return fallback;

    const data = await r.json();
    if (!data.iceServers || !Array.isArray(data.iceServers)) return fallback;

    // üî• FIX CH√çNH ·ªû ƒê√ÇY
    const cleanedIceServers = data.iceServers
      .map(server => {
        let urls = server.urls;
        if (!urls) return null;

        if (!Array.isArray(urls)) urls = [urls];

        // ‚ùå LO·∫†I B·ªé STUN TWILIO C√ì ?transport=
        const safeUrls = urls.filter(u =>
          typeof u === "string" &&
          !(u.startsWith("stun:") && u.includes("?transport="))
        );

        if (safeUrls.length === 0) return null;

        return {
          ...server,
          urls: safeUrls
        };
      })
      .filter(Boolean);

    if (cleanedIceServers.length === 0) return fallback;

    return { iceServers: cleanedIceServers };

  } catch (e) {
    console.error("ICE fetch error:", e);
    return fallback;
  }
}




    function log(msg) {
      logEl.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n` + logEl.textContent;
      console.log(msg);
    }

    socket.emit("join-room", { roomId, role: "broadcaster" });

    socket.on("watcher", async ({ viewerId }) => {
      if (!localStream) {
        log("C√≥ viewer nh∆∞ng b·∫°n ch∆∞a Start camera.");
        return;
      }
      log(`Viewer join: ${viewerId}`);

      const rtcConfig = await getRtcConfig();
const pc = new RTCPeerConnection(rtcConfig);



      pcs.set(viewerId, pc);

      // Add tracks
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          socket.emit("candidate", { to: viewerId, candidate: e.candidate });
        }
      };

      pc.oniceconnectionstatechange = () => {
        log(`ICE(${viewerId}): ${pc.iceConnectionState}`);
      };

      try {
        const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
        await pc.setLocalDescription(offer);
        socket.emit("offer", { to: viewerId, description: pc.localDescription });
      } catch (err) {
        log("L·ªói t·∫°o offer: " + err.message);
      }
    });

    socket.on("answer", async ({ from, description }) => {
      const pc = pcs.get(from);
      if (!pc) return;
      try {
        await pc.setRemoteDescription(description);
        log(`Nh·∫≠n answer t·ª´ viewer: ${from}`);
      } catch (err) {
        log("L·ªói setRemoteDescription(answer): " + err.message);
      }
    });

    socket.on("candidate", async ({ from, candidate }) => {
      const pc = pcs.get(from);
      if (!pc) return;
      try {
        await pc.addIceCandidate(candidate);
      } catch (err) {
        log("L·ªói addIceCandidate: " + err.message);
      }
    });

    socket.on("disconnectPeer", ({ peerId }) => {
      const pc = pcs.get(peerId);
      if (pc) {
        pc.close();
        pcs.delete(peerId);
        log(`Viewer r·ªùi: ${peerId} -> close peer`);
      }
    });

    socket.on("broadcaster-changed", () => {
      log("C√≥ broadcaster m·ªõi trong ph√≤ng (ƒëang l√† b·∫°n).");
    });

    async function start() {
      if (localStream) return;

      // Mobile best practice: request via user gesture (button click)
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: "user" },
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        });

        preview.srcObject = localStream;
        btnStart.disabled = true;
        btnStop.disabled = false;

        log("ƒê√£ Start camera + mic. G·ª≠i link xem cho ng∆∞·ªùi kh√°c.");

        socket.emit("broadcaster-ready", { roomId });

        // N·∫øu viewers ƒë√£ v√†o tr∆∞·ªõc, server s·∫Ω g·ª≠i danh s√°ch
        // M√¨nh s·∫Ω y√™u c·∫ßu h·ªç reload b·∫±ng broadcaster-online ƒë√£ ƒë·ªß.
      } catch (err) {
        log("Kh√¥ng m·ªü ƒë∆∞·ª£c camera/mic: " + err.message);
        alert("Kh√¥ng m·ªü ƒë∆∞·ª£c camera/mic. N·∫øu tr√™n ƒëi·ªán tho·∫°i: c·∫ßn HTTPS.");
      }
    }

    function stop() {
      if (!localStream) return;

      // close all peers
      for (const [id, pc] of pcs.entries()) {
        pc.close();
        pcs.delete(id);
      }

      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
      preview.srcObject = null;

      btnStart.disabled = false;
      btnStop.disabled = true;

      log("ƒê√£ Stop.");
    }

    btnStart.onclick = start;
    btnStop.onclick = stop;

    // cleanup on close
    window.addEventListener("beforeunload", stop);
  </script>
</body>
</html>
